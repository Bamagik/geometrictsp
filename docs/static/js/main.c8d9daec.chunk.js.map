{"version":3,"sources":["funcs.js","tsp.js","Graph.js","App.js","reportWebVitals.js","index.js"],"names":["sleep","ms","Promise","resolve","setTimeout","math","require","timeoutms","calculateDistance","p","q","v","x","y","norm","calculateAngle","r","v1","v2","acos","divide","dot","calculateEccentricity","convexHull","points","updateFunc","a","sort","b","hull","largestAngle","Infinity","bestNextPoint","includes","angle","length","push","slice","largestAngleTSP","difference","filter","idx","bestIdx","splice","eccentricEllipseTSP","largestEcc","ecc","nearestNeighborTSP","bestCost","bestTSP","startIdx","tsp","remainingPoints","bestDist","dist","cost","nearestNeighborMultiTSP","degree","Array","fill","tail","nnlink","pq","kdTree","nn","nearest","Number","edges","X","Ypt","Y","indexOf","remove","console","log","i","e","getRandomValue","max","Math","random","generateRandomData","count","from","map","Graph","props","startTSPCalculation","formula","state","name","data","currentTSP","setState","getNewData","addDataPoints","_","concat","removeDataPoints","updateCount","lines","this","width","height","xDomain","yDomain","animation","Button","onClick","Form","Control","value","onChange","event","target","as","custom","tooltip","React","Component","App","className","Container","Row","Col","sm","href","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.c8d9daec.chunk.js","sourcesContent":["\r\n/**\r\n * \r\n * @param {*} ms \r\n */\r\nexport function sleep(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n","import { kdTree } from 'kd-tree-javascript';\r\nimport { sleep } from './funcs';\r\n\r\nconst math = require('mathjs');\r\nconst timeoutms = 300;\r\n\r\nfunction calculateDistance(p, q) {\r\n    const v = [p.x - q.x, p.y - q.y];\r\n    return math.norm(v);\r\n}\r\n\r\nfunction calculateAngle(p, q, r) {\r\n    const v1 = [q.x - p.x, q.y - p.y]\r\n    const v2 = [r.x - p.x, r.y - p.y]\r\n\r\n    return math.acos( math.divide(math.dot(v1, v2), (math.norm(v1) * math.norm(v2) ) ) )\r\n}\r\n\r\nfunction calculateEccentricity(p, q, r) {\r\n    return calculateDistance(q, r) / \r\n        ( calculateDistance(p, q) + calculateDistance(p, r) );\r\n}\r\n\r\nfunction nearestNeighbor(pt, points) {\r\n    let bestDist = Infinity;\r\n    let bestIdx = null;\r\n    \r\n    for (const idx in points) {\r\n        const q = points[idx];\r\n        const dist = calculateDistance(q, pt);\r\n        if (dist < bestDist) {\r\n            bestDist = dist;\r\n            bestIdx = idx;\r\n        }\r\n    }\r\n\r\n    return bestIdx;\r\n}\r\n\r\n\r\n/**\r\n * @param {Array} points \r\n */\r\nexport async function convexHull(points, updateFunc) {\r\n    points = points.sort((a, b) => a.x - b.x);\r\n\r\n    let hull = [points[0]];\r\n\r\n    if (updateFunc) {\r\n        await updateFunc(hull);\r\n        await sleep(timeoutms);\r\n    }\r\n    \r\n    let largestAngle = -Infinity;\r\n    let bestNextPoint = null;\r\n\r\n    for (const p of points) {\r\n        if (hull.includes(p)) {\r\n            continue;\r\n        }\r\n        for (const q of points) {\r\n            if (hull.includes(q) || p === q) {\r\n                continue;\r\n            }\r\n            const angle = calculateAngle(hull[hull.length-1], p, q)\r\n            if (angle > largestAngle) {\r\n                largestAngle = angle;\r\n                bestNextPoint = q;\r\n            }\r\n        }\r\n    }\r\n    hull.push(bestNextPoint);\r\n    if (updateFunc) {\r\n        await updateFunc(hull);\r\n        await sleep(timeoutms);\r\n    }\r\n\r\n    while(hull.length < points.length) {\r\n        largestAngle = -Infinity;\r\n        bestNextPoint = null;\r\n        for (const p of points) {\r\n            if (hull.slice(-2).includes(p)) {\r\n                continue;\r\n            }\r\n            const angle = calculateAngle(hull[hull.length - 1], p, hull[hull.length - 2])\r\n            if (angle > largestAngle) {\r\n                largestAngle = angle;\r\n                bestNextPoint = p;\r\n            }\r\n        }\r\n        if (bestNextPoint === hull[0]) {\r\n            break\r\n        }\r\n        hull.push(bestNextPoint);\r\n        if (updateFunc) {\r\n            await updateFunc(hull);\r\n            await sleep(timeoutms);\r\n        }\r\n    }\r\n\r\n    return hull;\r\n}\r\n\r\n/**\r\n * @param {Array} points \r\n */\r\nexport async function largestAngleTSP(points, updateFunc) {\r\n    let hull = await convexHull(points, updateFunc);\r\n\r\n    let difference = points.filter((p) => !hull.includes(p));\r\n    difference = difference.sort((a, b) => a.x - b.x);\r\n    // console.log(difference);\r\n\r\n    for (const p of difference) {\r\n        if (updateFunc) {\r\n            await updateFunc(hull);\r\n            await sleep(timeoutms);\r\n        }\r\n\r\n        let largestAngle = -Infinity;\r\n        let bestIdx = null\r\n        \r\n        for (const idx in hull) {\r\n            const q = hull[idx];\r\n            const r = hull[(idx === '0' ? hull.length : idx) - 1];\r\n            const angle = calculateAngle(p, q, r);\r\n            if (angle > largestAngle) {\r\n                largestAngle = angle;\r\n                bestIdx = idx;\r\n            }\r\n        }\r\n        hull.splice(bestIdx, 0, p);\r\n    }\r\n\r\n    return hull;\r\n}\r\n\r\n/**\r\n * \r\n * @param {*} points \r\n * @param {*} updateFunc \r\n */\r\nexport async function eccentricEllipseTSP(points, updateFunc) {\r\n    let hull = await convexHull(points, updateFunc);\r\n\r\n    let difference = points.filter((p) => !hull.includes(p));\r\n    difference = difference.sort((a, b) => a.x - b.x);\r\n    // console.log(difference);\r\n\r\n    for (const p of difference) {\r\n        if (updateFunc) {\r\n            await updateFunc(hull);\r\n            await sleep(timeoutms);\r\n        }\r\n\r\n        let largestEcc = -Infinity;\r\n        let bestIdx = null;\r\n        \r\n        for (const idx in hull) {\r\n            const q = hull[idx];\r\n            const r = hull[(idx === '0' ? hull.length : idx) - 1];\r\n            const ecc = calculateEccentricity(p, q, r);\r\n            if (ecc > largestEcc) {\r\n                largestEcc = ecc;\r\n                bestIdx = idx;\r\n            }\r\n        }\r\n        hull.splice(bestIdx, 0, p);\r\n    }\r\n\r\n    return hull;\r\n}\r\n\r\nexport async function nearestNeighborTSP(points, updateFunc) {\r\n    let bestCost = Infinity;\r\n    let bestTSP = null;\r\n\r\n    for (const startIdx in points) {\r\n        let tsp = [points[startIdx]];\r\n        let remainingPoints = [...points];\r\n        remainingPoints.splice(startIdx, 1);\r\n\r\n        while (tsp.length !== points.length) {\r\n            let bestDist = Infinity;\r\n            let bestIdx = null;\r\n\r\n            for (const idx in remainingPoints) {\r\n                const dist = calculateDistance(remainingPoints[idx], tsp[tsp.length - 1])\r\n                if (dist < bestDist) {\r\n                    bestDist = dist;\r\n                    bestIdx = idx;\r\n                }\r\n            }\r\n            tsp.push(remainingPoints[bestIdx]);\r\n            remainingPoints.splice(bestIdx, 1);\r\n\r\n            if (updateFunc) {\r\n                await updateFunc(tsp);\r\n                await sleep(timeoutms/3);\r\n            }\r\n        }\r\n        let cost = 0;\r\n        for (const idx in tsp) {\r\n            const p = tsp[idx];\r\n            const q = tsp[(idx === '0' ? tsp.length : idx) - 1]\r\n\r\n            cost += calculateDistance(p, q);\r\n        }\r\n        if (cost < bestCost) {\r\n            bestCost = cost;\r\n            bestTSP = tsp;\r\n        }\r\n    }\r\n    return bestTSP;\r\n}\r\n\r\n/**\r\n * \r\n * @param {Array} points \r\n * @param {*} updateFunc \r\n */\r\nexport async function nearestNeighborMultiTSP(points, updateFunc) {\r\n    let degree = Array(points.length).fill(0);\r\n    let tail = Array(points.length).fill(-1);\r\n    let nnlink = [];\r\n    let pq = [];\r\n\r\n    for (const idx in points) {\r\n        let remainingPoints = points.slice();\r\n        remainingPoints.splice(idx, 1);\r\n        nnlink.push(new kdTree(remainingPoints, calculateDistance, [\"x\", \"y\"]));\r\n        pq.push({nn: nnlink[idx].nearest(points[idx], 1)[0], idx: Number(idx)})\r\n    }\r\n\r\n    let edges = []\r\n\r\n    let X, Y, nn = null;\r\n\r\n    while (edges.length < points.length - 1) {\r\n        while (true) {\r\n            pq = pq.sort((a, b) => a.nn[1] - b.nn[1]);\r\n            nn = pq[0].nn;\r\n            X = pq[0].idx;\r\n            if (degree[X] === 2) {\r\n                pq.splice(0, 1);\r\n                continue;\r\n            }\r\n            const [Ypt, thisDist] = nn;\r\n            Y = points.indexOf(Ypt);\r\n            \r\n            if (degree[Y] < 2 && Y !== tail[X]) {\r\n                break;\r\n            }\r\n            if (tail[X] !== -1) {\r\n                nnlink[X].remove(points[tail[X]]);\r\n            }\r\n            pq.splice(0, 1);\r\n            pq.push({nn: nnlink[X].nearest(points[X], 1)[0], idx: X});\r\n        }\r\n\r\n        edges.push([points[X], points[Y]]);\r\n        degree[X] += 1;\r\n        degree[Y] += 1;\r\n        if (degree[X] === 2) {\r\n            for (const tree of nnlink) {\r\n                tree.remove(points[X]);\r\n            }\r\n        }\r\n        if (degree[Y] === 2) {\r\n            for (const tree of nnlink) {\r\n                tree.remove(points[Y]);\r\n            }\r\n        }\r\n        pq.splice(0, 1);\r\n        pq.push({nn: nnlink[X].nearest(points[X], 1)[0], idx: X})\r\n\r\n        if (tail[X] !== -1) {\r\n            if (tail[Y] !== -1) {\r\n                tail[tail[X]] = tail[Y];\r\n                tail[tail[Y]] = tail[X];\r\n            } else {\r\n                tail[tail[X]] = Y;\r\n                tail[Y] = tail[X];\r\n            }\r\n        } else {\r\n            if (tail[Y] !== -1) {\r\n                tail[X] = tail[Y];\r\n                tail[tail[Y]] = X;\r\n            } else {\r\n                tail[X] = Y;\r\n                tail[Y] = X;\r\n            }\r\n        }\r\n    }\r\n\r\n    let tsp = [edges[0][0], edges[0][1]]\r\n\r\n    console.log(edges);\r\n    edges.splice(0, 1);\r\n\r\n    while (tsp.length < points.length) {\r\n        let i;\r\n        for (i in edges) {\r\n            const e = edges[i];\r\n            if (e[0] === tsp[0] && tsp[1] !== e[1]) {\r\n                tsp.splice(0, 0, e[1]);\r\n            } else if (e[1] === tsp[0] && tsp[1] !== e[0]) {\r\n                tsp.splice(0, 0, e[0]);\r\n            } else if (e[0] === tsp[tsp.length - 1] && tsp[tsp.length - 2] !== e[1]) {\r\n                tsp.push(e[1]);\r\n            } else if (e[1] === tsp[tsp.length - 1] && tsp[tsp.length - 2] !== e[0]) {\r\n                tsp.push(e[0]);\r\n            } else {\r\n                continue;\r\n            }\r\n            break;\r\n        }\r\n        edges.splice(i, 1);\r\n    }\r\n\r\n    return tsp;\r\n}","import React from 'react';\r\nimport { Button, Form } from 'react-bootstrap';\r\nimport RangeSlider from 'react-bootstrap-range-slider';\r\nimport {\r\n    XYPlot,\r\n    XAxis,\r\n    YAxis,\r\n    HorizontalGridLines,\r\n    VerticalGridLines,\r\n    MarkSeries,\r\n    LineSeries\r\n} from 'react-vis'\r\nimport { sleep } from './funcs';\r\nimport { eccentricEllipseTSP, largestAngleTSP, nearestNeighborMultiTSP, nearestNeighborTSP } from './tsp';\r\n\r\nconst INITIAL_COUNT = 20;\r\n\r\nfunction getRandomValue(max) {\r\n    return Math.random() * max;\r\n}\r\n\r\nfunction generateRandomData(count, max) {\r\n    return Array.from(Array(count)).map(() => ({x: getRandomValue(max), y: getRandomValue(max)}));\r\n}\r\n\r\nexport default class Graph extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            formula: eccentricEllipseTSP.name,\r\n            data: generateRandomData(INITIAL_COUNT, INITIAL_COUNT),\r\n            tsp: [],\r\n            lines: [],\r\n            count: INITIAL_COUNT\r\n        }\r\n    }\r\n\r\n    startTSPCalculation = async () => {\r\n        const {formula} = this.state;\r\n        let tsp = [];\r\n\r\n        if (formula === largestAngleTSP.name) {\r\n            tsp = await largestAngleTSP(this.state.data, (currentTSP) => this.setState({tsp: currentTSP}));\r\n        } else if (formula === eccentricEllipseTSP.name) {\r\n            tsp = await eccentricEllipseTSP(this.state.data, (currentTSP) => this.setState({tsp: currentTSP}));\r\n        } else if (formula === nearestNeighborTSP.name) {\r\n            tsp = await nearestNeighborTSP(this.state.data, (currentTSP) => this.setState({tsp: currentTSP}));\r\n        } else if (formula === nearestNeighborMultiTSP.name) {\r\n            tsp = await nearestNeighborMultiTSP(this.state.data, (currentTSP) => this.setState({tsp: currentTSP}));\r\n        }\r\n\r\n        this.setState({tsp});\r\n    }\r\n\r\n    getNewData = () => {\r\n        this.setState({data: generateRandomData(this.state.count, this.state.count), tsp: 0})\r\n    }\r\n\r\n    addDataPoints = (count) => {\r\n        this.setState((state, _) => ({data: state.data.concat(generateRandomData(count - state.data.length, state.count))}))\r\n    }\r\n\r\n    removeDataPoints = (count) => {\r\n        this.setState((state, _) => ({data: state.data.slice(0, state.data.length - count)}))\r\n    }\r\n\r\n    updateCount = (count) => {\r\n        if (count < this.state.count) {\r\n            this.removeDataPoints(count);\r\n        } else {\r\n            this.addDataPoints(count);\r\n        }\r\n        this.setState({count, tsp: [], lines: []});\r\n    }\r\n    \r\n    render() {\r\n        const {tsp, data, formula, count} = this.state\r\n\r\n        return <div>\r\n            <XYPlot width={300} height={300}\r\n                xDomain={[0-count/10, count+count/10]}\r\n                yDomain={[0-count/10, count+count/10]}\r\n            >\r\n                <VerticalGridLines />\r\n                <HorizontalGridLines />\r\n                <XAxis />\r\n                <YAxis />\r\n                <MarkSeries\r\n                    data={data}\r\n                    animation\r\n                />\r\n                <LineSeries\r\n                    data={tsp.length ? tsp.concat(tsp[0]) : []}\r\n                    animation\r\n                />\r\n            </XYPlot>\r\n            <Button onClick={this.getNewData}>Randomize Points</Button>\r\n            <Form.Control\r\n                value={formula}\r\n                onChange={(event) => this.setState({formula: event.target.value})}\r\n                as='select' \r\n                custom \r\n            >\r\n                <option value={eccentricEllipseTSP.name}>Most Eccentric Ellipse</option>\r\n                <option value={largestAngleTSP.name}>Largest Angle</option>\r\n                <option value={nearestNeighborTSP.name}>Nearest Neighbor</option>\r\n                <option value={nearestNeighborMultiTSP.name}>Multi-ended Nearest Neighbor</option>\r\n            </Form.Control>\r\n            <RangeSlider \r\n                value={count}\r\n                onChange={(e) => this.updateCount(Number(e.target.value))}\r\n                tooltip='on'\r\n            />\r\n            <Button onClick={this.startTSPCalculation}>Run TSP</Button>\r\n        </div>\r\n    }\r\n}","import './App.css';\nimport React from 'react';\nimport Graph from './Graph';\nimport { Col, Container, Row } from 'react-bootstrap';\n\nclass App extends React.Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <Container>\n          <Row>\n            <Col sm={10}>\n              <h1>Geometric Solutiosn to TSP</h1>\n              <h2>A report and exploration by Quintin Reed</h2>\n              \n              <p>This is a work in progress website that will act as the end location of findings in the feild.</p>\n              <p>All information here is aggregated from various resources that will be provided in the bibliography section at the bottom of the page.</p>\n              <p>Progess on this webpage will continue and get more in depth as the project progresses. This website will change to facilitate showing off the results.</p>\n\n              <h3>Project Timeline</h3>\n              <dl>\n                  <dt>Week 6-8</dt>\n                      <dd>Gather equations and start looking at recreating the functions in python</dd>\n                  <dt>Week 9</dt>\n                      <dd>Focus on updating the website with findings and midproject presentation</dd>\n                  <dt>Week 10</dt>\n                      <dd>Show findings and update progress according to response from presentation</dd>\n                  <dt>Week 11 - 14</dt>\n                      <dd>Recreate functions in JavaScript and create a website to showcase and visualize multiple TSP solutions</dd>\n                  <dt>Week 15</dt>\n                      <dd>Final Presentation and Finalize Website</dd>\n              </dl>\n\n              <h3>Bibliography</h3>\n              <ol>\n                  <li>Norback, J., & Love, R. (1977). \n                      <cite>Geometric Approaches to Solving the Traveling Salesman Problem. Management Science, 23(11), 1208-1223.</cite> \n                      <a href=\"http://www.jstor.org/stable/2630660\">http://www.jstor.org/stable/2630660</a>\n                  </li>\n                  <li>Bentley, J. J. (1992). \n                      <cite>Fast Algorithms for Geometric Traveling Salesman Problems. ORSA Journal on Computing, 4(4), 387.</cite>\n                      <a href=\"https://doi-org.ezproxy.rit.edu/10.1287/ijoc.4.4.387\">https://doi-org.ezproxy.rit.edu/10.1287/ijoc.4.4.387</a>\n                  </li>\n                  <li>Stanek Rostislav, et. al. (2019). \n                      <cite>Geometric and LP-based heuristics for angular travelling salesman problems in the plane. Compturs & Operations Research, 108, 97-111.</cite> \n                      <a href=\"https://www-sciencedirect-com.ezproxy.rit.edu/science/article/pii/S0305054819300188\">https://www-sciencedirect-com.ezproxy.rit.edu/science/article/pii/S0305054819300188</a>\n                  </li>\n              </ol>\n            </Col>\n            <Col sm={2}>\n              <Graph/>\n            </Col>\n          </Row>\n        </Container>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport 'react-vis/dist/style.css';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport 'react-bootstrap-range-slider/dist/react-bootstrap-range-slider.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}