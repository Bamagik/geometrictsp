{"version":3,"sources":["funcs.js","tsp.js","explanations.js","Graph.js","App.js","index.js"],"names":["sleep","ms","Promise","resolve","setTimeout","math","require","TIMEOUTMS","calculateDistance","p","q","v","x","y","norm","calculateAngle","r","v1","v2","acos","divide","dot","findBestInsertionPoint","Y","R","tsp","points","kdTree","slice","nearest","length","bestCost","Infinity","bestIdx","console","log","sort","a","b","indexOf","pt","idx","P","Q","cost","calculateCost","calculateEccentricity","convexHull","updateFunc","hull","largestAngle","bestNextPoint","includes","angle","push","largestAngleTSP","difference","filter","lastLine","splice","concat","Number","eccentricEllipseTSP","largestEcc","ecc","nearestNeighborTSP","bestTSP","startIdx","remainingPoints","tree","bestPt","remove","doubleEndNearestNeighborTSP","endpoints","bestDist","bestEndPt","endpt","xPt","thisDist","newestEdge","nearestNeighborMultiTSP","degree","Array","fill","tail","nnlink","pq","nn","edges","X","Ypt","i","e","nearestAdditionTSP","pointsCopy","Math","random","sp","insertIdx","farthestAdditionTSP","nnin","Xpt","oldX","insert","randomAdditionTSP","pop","minSpanTree","find","union","pidx","parent","rank","xroot","yroot","qidx","dist","mst","keys","zeros","minSpanTreeTSP","mst_traversal","node","adjacent","mst_edges","edge","globalEdges","mst_copy","altname","explanations","getRandomValue","max","generateRandomData","count","from","map","Graph","props","internalUpdate","lines","highlightPt","setState","startTSPCalculation","formula","state","running","data","getNewData","addDataPoints","_","removeDataPoints","updateCount","this","explanation","join","id","height","xDomain","yDomain","animation","line","style","stroke","strokeWidth","JSON","stringify","undefined","Row","Col","toFixed","value","onChange","target","tooltip","disabled","min","Button","className","onClick","Form","Control","event","as","custom","React","Component","App","Container","fluid","md","Tabs","defaultActiveKey","Tab","eventKey","title","xl","src","process","width","frameborder","allowfullscreen","mozallowfullscreen","webkitallowfullscreen","href","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.06e66d90.chunk.js","sourcesContent":["\r\n/**\r\n * \r\n * @param {*} ms \r\n */\r\nexport function sleep(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n","import { kdTree } from 'kd-tree-javascript';\r\nimport { sleep } from './funcs';\r\n\r\nconst math = require('mathjs');\r\n\r\nconst TIMEOUTMS = 250;\r\nconst ADDRAD = 2\r\n\r\n/**\r\n * Calculate euclidean distance\r\n * @param {Object} p point p\r\n * @param {Object} q point q\r\n */\r\nfunction calculateDistance(p, q) {\r\n    const v = [p.x - q.x, p.y - q.y];\r\n    return math.norm(v);\r\n}\r\n\r\n/**\r\n * Calculate angle of q-p-r, where p is the vertex\r\n * @param {Object} p vertex\r\n * @param {Object} q point q\r\n * @param {Object} r point r\r\n */\r\nfunction calculateAngle(p, q, r) {\r\n    const v1 = [q.x - p.x, q.y - p.y]\r\n    const v2 = [r.x - p.x, r.y - p.y]\r\n\r\n    return math.acos( math.divide(math.dot(v1, v2), (math.norm(v1) * math.norm(v2) ) ) )\r\n}\r\n\r\n/**\r\n * Find the best cost insertion area in the TSP for a point Y with radial-ball distance R*2\r\n * @param {Object} Y point Y\r\n * @param {Number} R distance\r\n * @param {Object[]} tsp tsp tour\r\n */\r\nfunction findBestInsertionPoint(Y, R, tsp) {\r\n    const tree = new kdTree(tsp.slice(), calculateDistance, ['x', 'y']);\r\n\r\n    let points = tree.nearest(Y, tsp.length, R * ADDRAD)\r\n\r\n    let bestCost = Infinity;\r\n    let bestIdx = null;\r\n\r\n    console.log(Y, tsp.slice())\r\n\r\n    points = points.sort((a, b) => tsp.indexOf(a[0]) - tsp.indexOf(b[0]))\r\n\r\n    for (let pt of points) {\r\n        const idx = tsp.indexOf(pt[0])\r\n        const P = tsp[idx]\r\n        const Q = tsp[(idx === 0 ? tsp.length : idx) - 1]\r\n\r\n        // console.log(P, Q)\r\n\r\n        let cost = calculateDistance(P, Y) + calculateDistance(Y, Q);\r\n\r\n        // console.log(cost)\r\n\r\n        if (cost < bestCost) {\r\n            bestIdx = idx;\r\n            bestCost = cost;\r\n        }\r\n    }\r\n\r\n    console.log(bestIdx, bestCost)\r\n\r\n    return bestIdx;\r\n}\r\n\r\n/**\r\n * Calculate the cost of the TSP tour.\r\n * @param {Object[]} tsp tsp tour\r\n */\r\nexport function calculateCost(tsp) {\r\n    let cost = 0;\r\n    for (const idx in tsp) {\r\n        const p = tsp[idx];\r\n        const q = tsp[(idx === '0' ? tsp.length : idx) - 1]\r\n\r\n        cost += calculateDistance(p, q);\r\n    }\r\n    return cost\r\n}\r\n\r\n/**\r\n * Calculate the eccentricity of an ellipse with foci q and r and point p.\r\n * @param {Object} p edge point\r\n * @param {Object} q foci\r\n * @param {Object} r foci\r\n */\r\nfunction calculateEccentricity(p, q, r) {\r\n    return calculateDistance(q, r) / \r\n        ( calculateDistance(p, q) + calculateDistance(p, r) );\r\n}\r\n\r\n\r\n/**\r\n * Find the convex hull from a set of points\r\n * @param {Object[]} points points list\r\n * @param {Function} updateFunc update function for the UI, can be undefined.\r\n */\r\nexport async function convexHull(points, updateFunc) {\r\n    points = points.sort((a, b) => a.x - b.x);\r\n\r\n    let hull = [points[0]];\r\n\r\n    if (updateFunc) {\r\n        await updateFunc(hull);\r\n        await sleep(TIMEOUTMS);\r\n    }\r\n    \r\n    let largestAngle = -Infinity;\r\n    let bestNextPoint = null;\r\n\r\n    for (const p of points) {\r\n        if (hull.includes(p)) {\r\n            continue;\r\n        }\r\n        for (const q of points) {\r\n            if (hull.includes(q) || p === q) {\r\n                continue;\r\n            }\r\n            const angle = calculateAngle(hull[hull.length-1], p, q)\r\n            if (angle > largestAngle) {\r\n                largestAngle = angle;\r\n                bestNextPoint = q;\r\n            }\r\n        }\r\n    }\r\n    hull.push(bestNextPoint);\r\n    if (updateFunc) {\r\n        await updateFunc(hull, 0, [hull.slice(hull.length - 2)]);\r\n        await sleep(TIMEOUTMS);\r\n    }\r\n\r\n    while(hull.length < points.length) {\r\n        largestAngle = -Infinity;\r\n        bestNextPoint = null;\r\n        for (const p of points) {\r\n            if (hull.slice(-2).includes(p)) {\r\n                continue;\r\n            }\r\n            const angle = calculateAngle(hull[hull.length - 1], p, hull[hull.length - 2])\r\n            if (angle > largestAngle) {\r\n                largestAngle = angle;\r\n                bestNextPoint = p;\r\n            }\r\n        }\r\n        if (bestNextPoint === hull[0]) {\r\n            break\r\n        }\r\n        hull.push(bestNextPoint);\r\n        if (updateFunc) {\r\n            await updateFunc(hull, 0, [hull.slice(hull.length - 2)]);\r\n            await sleep(TIMEOUTMS);\r\n        }\r\n    }\r\n\r\n    return hull;\r\n}\r\n\r\n/**\r\n * Largest Angle Heurisitic for Convex Hull TSP\r\n * @param {Object[]} points points list\r\n */\r\nexport async function largestAngleTSP(points, updateFunc) {\r\n    // get cconvex hull\r\n    let hull = await convexHull(points, updateFunc);\r\n\r\n    let difference = points.filter((p) => !hull.includes(p));\r\n    difference = difference.sort((a, b) => a.x - b.x);\r\n    // console.log(difference);\r\n\r\n    let lastLine = [];\r\n\r\n    for (const p of difference) {\r\n        if (updateFunc) {\r\n            await updateFunc(hull, 0, [lastLine]);\r\n            await sleep(TIMEOUTMS);\r\n        }\r\n\r\n        let largestAngle = -Infinity;\r\n        let bestIdx = null\r\n        \r\n        for (const idx in hull) {\r\n            const q = hull[idx];\r\n            const r = hull[(idx === '0' ? hull.length : idx) - 1];\r\n            const angle = calculateAngle(p, q, r);\r\n            if (angle > largestAngle) {\r\n                largestAngle = angle;\r\n                bestIdx = idx;\r\n            }\r\n        }\r\n        hull.splice(bestIdx, 0, p);\r\n\r\n        const r = hull[(bestIdx === '0' ? hull.length : bestIdx) - 1];\r\n        lastLine = [r].concat(hull.slice(Number(bestIdx), Number(bestIdx) + 2));\r\n    }\r\n\r\n    if (updateFunc) {\r\n        await updateFunc(hull, 0, [lastLine]);\r\n        await sleep(TIMEOUTMS);\r\n    }\r\n\r\n    return hull;\r\n}\r\nlargestAngleTSP.altname = \"largestAngleTSP\";\r\n\r\n/**\r\n * Most Eccentric Ellipse Heurisitc for Convex Hull TSP\r\n * @param {Object[]} points points list.\r\n * @param {Function} updateFunc update function for UI, can be undefined.\r\n */\r\nexport async function eccentricEllipseTSP(points, updateFunc) {\r\n    // get convex hull\r\n    let hull = await convexHull(points, updateFunc);\r\n\r\n    let difference = points.filter((p) => !hull.includes(p));\r\n    difference = difference.sort((a, b) => a.x - b.x);\r\n    // console.log(difference);\r\n\r\n    let lastLine = [];\r\n\r\n    for (const p of difference) {\r\n        if (updateFunc) {\r\n            await updateFunc(hull, 0, [lastLine]);\r\n            await sleep(TIMEOUTMS);\r\n        }\r\n\r\n        let largestEcc = -Infinity;\r\n        let bestIdx = null;\r\n        \r\n        for (const idx in hull) {\r\n            const q = hull[idx];\r\n            const r = hull[(idx === '0' ? hull.length : idx) - 1];\r\n            const ecc = calculateEccentricity(p, q, r);\r\n            if (ecc > largestEcc) {\r\n                largestEcc = ecc;\r\n                bestIdx = idx;\r\n            }\r\n        }\r\n        hull.splice(bestIdx, 0, p);\r\n\r\n        const r = hull[(bestIdx === '0' ? hull.length : bestIdx) - 1];\r\n        lastLine = [r].concat(hull.slice(Number(bestIdx), Number(bestIdx) + 2));\r\n    }\r\n\r\n    if (updateFunc) {\r\n        await updateFunc(hull, 0, [lastLine]);\r\n        await sleep(TIMEOUTMS);\r\n    }\r\n\r\n    return hull;\r\n}\r\neccentricEllipseTSP.altname = \"eccentricEllipseTSP\";\r\n\r\n/**\r\n * Nearest Neighbor TSP. Single-ended.\r\n * @param {Object[]} points points list\r\n * @param {Function} updateFunc update function for UI. can be undefined.\r\n */\r\nexport async function nearestNeighborTSP(points, updateFunc) {\r\n    let bestCost = Infinity;\r\n    let bestTSP = null;\r\n\r\n    for (const startIdx in points) {\r\n        let tsp = [points[startIdx]];\r\n        let remainingPoints = [...points];\r\n        remainingPoints.splice(startIdx, 1);\r\n\r\n        let tree = new kdTree(remainingPoints, calculateDistance, ['x', 'y']);\r\n\r\n        while (tsp.length !== points.length) {\r\n            let [bestPt, bestDist] = tree.nearest(tsp[tsp.length - 1], 1)[0]\r\n            tsp.push(bestPt);\r\n            tree.remove(bestPt);\r\n\r\n            if (updateFunc) {\r\n                await updateFunc(tsp, bestCost, [tsp.slice(tsp.length-2)]);\r\n                await sleep(TIMEOUTMS/3);\r\n            }\r\n        }\r\n        const cost = calculateCost(tsp)\r\n        if (cost < bestCost) {\r\n            bestCost = cost;\r\n            bestTSP = tsp;\r\n        }\r\n\r\n        if (updateFunc) {\r\n            await updateFunc(tsp, bestCost, [tsp.slice(tsp.length-2)]);\r\n            await sleep(TIMEOUTMS/3);\r\n        }\r\n    }\r\n    return bestTSP;\r\n}\r\nnearestNeighborTSP.altname = \"nearestNeighborTSP\";\r\n\r\n\r\n/**\r\n * Double ended nearest neighbor TSP. uses both ends to add to the tour.\r\n * @param {Object[]} points points list\r\n * @param {Function} updateFunc update function for UI. can be undefined.\r\n */\r\nexport async function doubleEndNearestNeighborTSP(points, updateFunc) {\r\n    let bestCost = Infinity;\r\n    let bestTSP = null;\r\n\r\n    for (const startIdx in points) {\r\n        let tsp = [points[startIdx]];\r\n        let remainingPoints = [...points];\r\n        remainingPoints.splice(startIdx, 1);\r\n\r\n        let tree = new kdTree(remainingPoints, calculateDistance, ['x', 'y']);\r\n\r\n        while (tsp.length !== points.length) {\r\n            const endpoints = [tsp[0], tsp[tsp.length - 1]]\r\n\r\n            let bestPt = null;\r\n            let bestDist = Infinity;\r\n            let bestEndPt = null;\r\n\r\n            for (let endpt of endpoints) {\r\n                let [xPt, thisDist] = tree.nearest(endpt, 1)[0];\r\n\r\n                if (thisDist < bestDist) {\r\n                    bestDist = thisDist;\r\n                    bestPt = xPt;\r\n                    bestEndPt = endpt;\r\n                }\r\n            }\r\n\r\n            let newestEdge = []\r\n\r\n            if (bestEndPt === endpoints[1]) {\r\n                tsp.push(bestPt);\r\n                newestEdge = tsp.slice(tsp.length-2);\r\n            } else {\r\n                tsp.splice(0, 0, bestPt);\r\n                newestEdge = tsp.slice(0, 2);\r\n            }\r\n            tree.remove(bestPt);\r\n\r\n            if (updateFunc) {\r\n                await updateFunc(tsp, bestCost, [newestEdge], [bestEndPt]);\r\n                await sleep(TIMEOUTMS/2);\r\n            }\r\n        }\r\n        const cost = calculateCost(tsp)\r\n        if (cost < bestCost) {\r\n            bestCost = cost;\r\n            bestTSP = tsp;\r\n        }\r\n\r\n        if (updateFunc) {\r\n            await updateFunc(tsp, bestCost, [tsp.slice(tsp.length-2)]);\r\n            await sleep(TIMEOUTMS/2);\r\n        }\r\n    }\r\n    return bestTSP;\r\n}\r\ndoubleEndNearestNeighborTSP.altname = \"doubleEndNearestNeighborTSP\";\r\n\r\n\r\n/**\r\n * Nearest Neighbor Multi-Fragment TSP. Build up TSP from individual smaller edges.\r\n * @param {Object[]} points points list\r\n * @param {Function} updateFunc update function for UI, can be undefined.\r\n */\r\nexport async function nearestNeighborMultiTSP(points, updateFunc) {\r\n    let degree = Array(points.length).fill(0);\r\n    let tail = Array(points.length).fill(-1);\r\n    let nnlink = [];\r\n    let pq = [];\r\n\r\n    for (const idx in points) {\r\n        let remainingPoints = points.slice();\r\n        remainingPoints.splice(idx, 1);\r\n        nnlink.push(new kdTree(remainingPoints, calculateDistance, [\"x\", \"y\"]));\r\n        pq.push({nn: nnlink[idx].nearest(points[idx], 1)[0], idx: Number(idx)})\r\n    }\r\n\r\n    let edges = []\r\n\r\n    let X, Y, nn = null;\r\n\r\n    while (edges.length < points.length - 1) {\r\n        if (updateFunc) {\r\n            await updateFunc([], 0, edges);\r\n            await sleep(TIMEOUTMS);\r\n        }\r\n\r\n        while (true) {\r\n            pq = pq.sort((a, b) => a.nn[1] - b.nn[1]);\r\n            nn = pq[0].nn;\r\n            X = pq[0].idx;\r\n            if (degree[X] === 2) {\r\n                pq.splice(0, 1);\r\n                continue;\r\n            }\r\n            const [Ypt, thisDist] = nn;\r\n            Y = points.indexOf(Ypt);\r\n            \r\n            if (degree[Y] < 2 && Y !== tail[X]) {\r\n                break;\r\n            }\r\n            if (tail[X] !== -1) {\r\n                nnlink[X].remove(points[tail[X]]);\r\n            }\r\n            pq.splice(0, 1);\r\n            pq.push({nn: nnlink[X].nearest(points[X], 1)[0], idx: X});\r\n        }\r\n\r\n        edges.push([points[X], points[Y]]);\r\n        degree[X] += 1;\r\n        degree[Y] += 1;\r\n        if (degree[X] === 2) {\r\n            for (const tree of nnlink) {\r\n                tree.remove(points[X]);\r\n            }\r\n        }\r\n        if (degree[Y] === 2) {\r\n            for (const tree of nnlink) {\r\n                tree.remove(points[Y]);\r\n            }\r\n        }\r\n        pq.splice(0, 1);\r\n        pq.push({nn: nnlink[X].nearest(points[X], 1)[0], idx: X})\r\n\r\n        if (tail[X] !== -1) {\r\n            if (tail[Y] !== -1) {\r\n                tail[tail[X]] = tail[Y];\r\n                tail[tail[Y]] = tail[X];\r\n            } else {\r\n                tail[tail[X]] = Y;\r\n                tail[Y] = tail[X];\r\n            }\r\n        } else {\r\n            if (tail[Y] !== -1) {\r\n                tail[X] = tail[Y];\r\n                tail[tail[Y]] = X;\r\n            } else {\r\n                tail[X] = Y;\r\n                tail[Y] = X;\r\n            }\r\n        }\r\n    }\r\n\r\n    let tsp = [edges[0][0], edges[0][1]]\r\n\r\n    console.log(edges);\r\n    edges.splice(0, 1);\r\n\r\n    while (tsp.length < points.length) {\r\n        let i;\r\n        for (i in edges) {\r\n            const e = edges[i];\r\n            if (e[0] === tsp[0] && tsp[1] !== e[1]) {\r\n                tsp.splice(0, 0, e[1]);\r\n            } else if (e[1] === tsp[0] && tsp[1] !== e[0]) {\r\n                tsp.splice(0, 0, e[0]);\r\n            } else if (e[0] === tsp[tsp.length - 1] && tsp[tsp.length - 2] !== e[1]) {\r\n                tsp.push(e[1]);\r\n            } else if (e[1] === tsp[tsp.length - 1] && tsp[tsp.length - 2] !== e[0]) {\r\n                tsp.push(e[0]);\r\n            } else {\r\n                continue;\r\n            }\r\n            break;\r\n        }\r\n        edges.splice(i, 1);\r\n    }\r\n\r\n    return tsp;\r\n}\r\nnearestNeighborMultiTSP.altname = \"nearestNeighborMultiTSP\";\r\n\r\n/**\r\n * Nearest Addition TSP. Build up TSP by finding nearest points, smart insertion.\r\n * @param {Object[]} points points list\r\n * @param {Function} updateFunc update function for UI, can be undefined.\r\n */\r\nexport async function nearestAdditionTSP(points, updateFunc) {\r\n    let idx = 0;\r\n\r\n    const pointsCopy = points.slice().sort(() => Math.random() - 0.5);\r\n\r\n    const sp = pointsCopy[idx];\r\n\r\n    // console.log(points)\r\n\r\n    let remainingPoints = pointsCopy.slice();\r\n    remainingPoints.splice(idx, 1);\r\n\r\n    let tree = new kdTree(remainingPoints, calculateDistance, ['x', 'y']);\r\n    let pq = [{nn: tree.nearest(sp, 1)[0], idx: Number(idx)}]\r\n\r\n    let tsp = [sp];\r\n    let insertIdx = 0;\r\n\r\n    while (tsp.length < pointsCopy.length) {\r\n        let Y, thisDist, Ypt;\r\n\r\n        if (updateFunc && tsp.length > 1) {            \r\n            let edges = []\r\n            if (tsp.length > 1) {\r\n                edges.push(tsp[(insertIdx - 1 === -1) ? tsp.length - 1: insertIdx - 1]);\r\n                edges.push(tsp[insertIdx]);\r\n                edges.push(tsp[(insertIdx + 1 === tsp.length) ? 1 : insertIdx + 1])\r\n            }\r\n            await updateFunc(tsp, 0, [edges]);\r\n            await sleep(TIMEOUTMS);\r\n        }\r\n\r\n        while (true) {\r\n            pq = pq.sort((a, b) => a.nn[1] - b.nn[1]);\r\n            // console.log(pq)\r\n            const nn = pq[0].nn;\r\n            const X = pq[0].idx;    \r\n            [Ypt, thisDist] = nn;\r\n            Y = pointsCopy.indexOf(Ypt);\r\n\r\n            if (!tsp.includes(Ypt)) {\r\n                break;\r\n            }\r\n            tree.remove(Ypt);\r\n            pq.splice(0, 1);\r\n            pq.push({nn: tree.nearest(pointsCopy[X], 1)[0], idx: X});\r\n        }\r\n\r\n        insertIdx = findBestInsertionPoint(pointsCopy[Y], thisDist, tsp);\r\n        tsp.splice(insertIdx, 0, pointsCopy[Y]);\r\n        console.log(tsp.slice())\r\n        remainingPoints.splice(remainingPoints.indexOf(pointsCopy[Y]), 1);\r\n        tree.remove(pointsCopy[Y]);\r\n\r\n        pq = []\r\n        for (let pt of tsp) {\r\n            pq.push({nn: tree.nearest(pt, 1)[0], idx: pointsCopy.indexOf(pt)})\r\n        }\r\n    }\r\n\r\n    if (updateFunc) {\r\n        await updateFunc(tsp);\r\n        await sleep(TIMEOUTMS);\r\n    }\r\n    \r\n    return tsp;\r\n}\r\nnearestAdditionTSP.altname = \"nearestAdditionTSP\";\r\n\r\n\r\n/**\r\n * Farthest Addition TSP. Build up TSP by finding farthest points. Smart insertion.\r\n * @param {Object[]} points points list\r\n * @param {Function} updateFunc update function for UI, can be undefined.\r\n */\r\nexport async function farthestAdditionTSP(points, updateFunc) {\r\n    let idx = 0;\r\n    const pointsCopy = points.slice().sort(() => Math.random() - 0.5);\r\n    const sp = pointsCopy[idx];\r\n\r\n    let tsp = [sp];\r\n    let tree = new kdTree(tsp, calculateDistance, ['x', 'y']);\r\n\r\n    let nnin = new Array(points.length);\r\n    let pq = []\r\n\r\n    let insertIdx = 0;\r\n\r\n    for (let i in points) {\r\n        if (Number(i) !== idx) {\r\n            nnin[i] = 0\r\n            pq.push({nn: tree.nearest(points[i], 1)[0], idx: i});\r\n        }\r\n    }\r\n\r\n    while (tsp.length < points.length) {\r\n        let thisDist, Xpt, Y, nn;\r\n\r\n        if (updateFunc && tsp.length > 1) {            \r\n            let edges = []\r\n            if (tsp.length > 1) {\r\n                edges.push(tsp[(insertIdx - 1 === -1) ? tsp.length - 1: insertIdx - 1]);\r\n                edges.push(tsp[insertIdx]);\r\n                edges.push(tsp[(insertIdx + 1 === tsp.length) ? 1 : insertIdx + 1])\r\n            }\r\n            await updateFunc(tsp, 0, [edges]);\r\n            await sleep(TIMEOUTMS);\r\n        }\r\n\r\n        while (true) {\r\n            pq = pq.sort((a, b) => a.nn[1] - b.nn[1]);\r\n            \r\n            nn = pq[pq.length-1].nn;\r\n            Y = pq[pq.length-1].idx;\r\n            [Xpt, thisDist] = nn;\r\n            const oldX = pointsCopy.indexOf(Xpt);\r\n            nnin[Y] = pointsCopy.indexOf(tree.nearest(pointsCopy[Y], 1)[0][0]);\r\n            let X = nnin[Y];\r\n            if (X === oldX) {\r\n                break; \r\n            }\r\n            pq.splice(pq.length-1, 1);\r\n            pq.push({nn: tree.nearest(pointsCopy[Y], 1)[0], idx: Y});\r\n        }\r\n\r\n        insertIdx = findBestInsertionPoint(pointsCopy[Y], thisDist, tsp);\r\n        tsp.splice(insertIdx, 0, pointsCopy[Y]);\r\n        tree.insert(pointsCopy[Y]);\r\n        pq.splice(pq.length-1, 1);\r\n    }\r\n\r\n    if (updateFunc) {\r\n        await updateFunc(tsp);\r\n        await sleep(TIMEOUTMS);\r\n    }\r\n\r\n    return tsp\r\n}\r\nfarthestAdditionTSP.altname = \"farthestAdditionTSP\";\r\n\r\n\r\n/**\r\n * Random Addition TSP. Build up TSP by using random points with smart insertion.\r\n * @param {Object[]} points points list.\r\n * @param {Function} updateFunc update function for UI, can be undefined\r\n */\r\nexport async function randomAdditionTSP(points, updateFunc) {\r\n    const pointsCopy = points.slice().sort(() => Math.random() - 0.5);\r\n    const idx = 0;\r\n    const sp = pointsCopy[0];\r\n\r\n    let tsp = [sp];\r\n    let tree = new kdTree(tsp, calculateDistance, ['x', 'y']);\r\n    \r\n    let remainingPoints = pointsCopy.slice();\r\n    remainingPoints.splice(idx, 1);\r\n\r\n    let insertIdx = 0;\r\n\r\n    while (tsp.length < points.length) {\r\n        const Ypt = remainingPoints.pop();\r\n        let [Xpt, thisDist] = tree.nearest(Ypt, 1)[0];\r\n\r\n        insertIdx = findBestInsertionPoint(Ypt, thisDist, tsp);\r\n        tsp.splice(insertIdx, 0, Ypt);\r\n        tree.insert(Ypt);\r\n\r\n        if (updateFunc) {            \r\n            let edges = []\r\n            if (tsp.length > 1) {\r\n                edges.push(tsp[(insertIdx - 1 === -1) ? tsp.length - 1: insertIdx - 1]);\r\n                edges.push(tsp[insertIdx]);\r\n                edges.push(tsp[(insertIdx + 1 === tsp.length) ? 1 : insertIdx + 1])\r\n            }\r\n            await updateFunc(tsp, 0, [edges]);\r\n            await sleep(TIMEOUTMS);\r\n        }\r\n    }\r\n\r\n    return tsp;\r\n}\r\nrandomAdditionTSP.altname = \"randomAdditionTSP\";\r\n\r\n/**\r\n * Min Span Tree algorithm\r\n * @param {Object[]} points points list\r\n * @param {Function} updateFunc update function for UI, can be undefined.\r\n */\r\nasync function minSpanTree(points, updateFunc) {\r\n    /**\r\n     * Find the parent of i to see if they share the same tree.\r\n     * This is to make sure that two branches don't connect.\r\n     * @param {Number[]} parent parent based index array.\r\n     * @param {Number} i index\r\n     */\r\n    function find(parent, i) {\r\n        if (parent[i] == i) {\r\n            return i\r\n        }\r\n        return find(parent, parent[i])\r\n    }\r\n    /**\r\n     * Union of the two points, adjust the parent array and ranks\r\n     * @param {Number[]} parent parent list of branches\r\n     * @param {Number[]} rank rank of point, the higher the more branches come off of it.\r\n     * @param {Number} x x point\r\n     * @param {Number} y y point\r\n     */\r\n    function union(parent, rank, x, y) {\r\n        const xroot = find(parent, x);\r\n        const yroot = find(parent, y);\r\n        \r\n        if (rank[xroot] < rank[yroot]) {\r\n            parent[xroot] = yroot;\r\n        } else if (rank[xroot] > rank[yroot]) {\r\n            parent[yroot] = xroot;\r\n        } else {\r\n            parent[yroot] = xroot;\r\n            rank[xroot] += 1;\r\n        }\r\n    }\r\n\r\n    let edges = [];\r\n\r\n    for (let pidx in points.slice(0, points.length - 1)) {\r\n        const p = points[pidx];\r\n        for (let qidx in points.slice(Number(pidx)+1)) {\r\n            const q = points[Number(pidx) + 1 + Number(qidx)];\r\n            edges.push({dist: calculateDistance(p, q), pidx, qidx: Number(pidx) + 1 + Number(qidx)})\r\n        }\r\n    }\r\n    edges.sort((a, b) => a.dist - b.dist);\r\n\r\n    let mst = [];\r\n\r\n    let parent = [...Array(points.length).keys()];\r\n    let rank = math.zeros(points.length);\r\n\r\n    while (mst.length < points.length - 1) {\r\n        const {dist, pidx, qidx} = edges.splice(0, 1)[0];\r\n\r\n        const x = find(parent, pidx);\r\n        const y = find(parent, qidx);\r\n\r\n        if (x != y) {\r\n            mst.push([points[pidx], points[qidx]]);\r\n            union(parent, rank, x, y);\r\n\r\n            if (updateFunc) {            \r\n                await updateFunc([], 0, mst);\r\n                await sleep(TIMEOUTMS);\r\n            }\r\n        }\r\n    }\r\n\r\n    console.log(mst);\r\n\r\n    return mst;\r\n}\r\n\r\n\r\n/**\r\n * MST TSP solution. Use pre-order traversal after finding MST.\r\n * @param {*} points \r\n * @param {*} updateFunc \r\n */\r\nexport async function minSpanTreeTSP(points, updateFunc) {\r\n    let globalEdges = [];\r\n    \r\n    /**\r\n     * MST Pre-order traversal to create TSP.\r\n     * @param {Object} node \r\n     * @param {Object[][]} mst \r\n     */\r\n    async function mst_traversal(node, mst) {\r\n        let adjacent = [];\r\n        let mst_edges = [];\r\n\r\n        for (let idx in mst) {\r\n            const edge = mst[idx];\r\n            if (edge[0] === node) {\r\n                adjacent.push(edge[1]);\r\n                mst_edges.push(idx);\r\n            }\r\n            if (edge[1] === node) {\r\n                adjacent.push(edge[0]);\r\n                mst_edges.push(idx);  \r\n            }  \r\n        }   \r\n\r\n        let tsp = [node];\r\n\r\n        for (let idx in adjacent) {\r\n            globalEdges.push([node, adjacent[idx]])\r\n\r\n            let mst_copy = mst.slice();\r\n            mst_copy.splice(mst_edges[idx], 1);\r\n            tsp.push(...await mst_traversal(adjacent[idx], mst_copy));\r\n        }\r\n\r\n        return tsp;\r\n    }\r\n\r\n    const mst = await minSpanTree(points, updateFunc);\r\n\r\n    const tsp = await mst_traversal(points[0], mst);\r\n\r\n    // console.log(tsp);\r\n\r\n    return tsp;\r\n}\r\nminSpanTreeTSP.altname = \"minSpanTreeTSP\";","export var explanations = {\r\n    \"largestAngleTSP\": \r\n        [\r\n            \"This method starts with finding the convex hull of the set of points.\",\r\n            \"From there we look at the internal points starting from left to right,\",\r\n            \"and calculate between which existing points in the convex hull has the largest angle to the given point. [1]\"\r\n        ],\r\n    \"eccentricEllipseTSP\":\r\n        [\r\n            \"This method starts with finding the convex hull of the set of points.\",\r\n            \"From there we look at the internal points starting from left to right,\",\r\n            \"and calculate between which existing points in the convex hull has teh most eccentric ellipse\",\r\n            \"with respect to the given point. [1]\"\r\n        ],\r\n    \"nearestNeighborTSP\":\r\n        [\r\n            \"This method is about finding the nearest point to the end of the current cycle.\",\r\n            \"Using every point as a potential starting point, it looks for the lowest cost tour through all the points,\",\r\n            \"basing the finding of the next point by nearest neighbor approach. [2]\"\r\n        ],\r\n    \"doubleEndNearestNeighborTSP\":\r\n        [\r\n            \"This method is about finding the nearest point to EITHER end of the current tour.\",\r\n            \"Using every point as a potential starting point, it looks for the lowest cost tour through all the points,\",\r\n            \"basing the finding of the next point by nearest neighbor approach. [2]\"\r\n        ],\r\n    \"nearestNeighborMultiTSP\":\r\n        [\r\n            \"This method is an extension of the standard nearest neighbor approach.\",\r\n            \"This method adds edges from smallest to largest until a tour is achieved. [2]\"\r\n        ],\r\n    \"nearestAdditionTSP\":\r\n        [\r\n            \"This method is an optimized form of nearest neighbor.\",\r\n            \"Utilizing a KDTree, nearest addition assumes randomness in the starting points,\",\r\n            \"and from those adds points based on proximity to a point in the tsp, and inserts it smartly\",\r\n            \"based on where the minimum cost is in the tsp. [2]\"\r\n        ],\r\n    \"farthestAdditionTSP\":\r\n        [\r\n            \"This method is an optimized form of nearest neighbor.\",\r\n            \"Utilizing a KDTree, farthest addition assumes randomness in the starting points,\",\r\n            \"and from those adds points that are farthest from the tsp first. [2]\"\r\n        ],\r\n    \"randomAdditionTSP\":\r\n        [\r\n            \"This method is an optimized form of nearest neighbor.\",\r\n            \"Utilizing a KDTree, random addition takes random points and\",\r\n            \"finds optimal locations for insertion in the existing TSP. [2]\"\r\n        ],\r\n    \"minSpanTreeTSP\": \r\n        [\r\n            \"This method creates an MST and from the MST it creates a tour\",\r\n            \"of points based on Pre-Order Traversal from the first point in the list. [2]\",\r\n            \"For this algorithm to be improved, the use of a heuristic other than Pre-Order Traversal would benefit the algorithm.\"\r\n        ],\r\n    \"undefined\": [ \"placeholder\" ]\r\n};\r\n\r\nexport default explanations;","import React from 'react';\r\nimport { Button, Col, Form, Row } from 'react-bootstrap';\r\nimport RangeSlider from 'react-bootstrap-range-slider';\r\nimport {\r\n    XAxis,\r\n    YAxis,\r\n    HorizontalGridLines,\r\n    VerticalGridLines,\r\n    MarkSeries,\r\n    LineSeries,\r\n    FlexibleWidthXYPlot\r\n} from 'react-vis';\r\nimport { \r\n    calculateCost, \r\n    eccentricEllipseTSP, \r\n    largestAngleTSP, \r\n    nearestNeighborMultiTSP, \r\n    nearestNeighborTSP, \r\n    nearestAdditionTSP, \r\n    farthestAdditionTSP, \r\n    randomAdditionTSP,\r\n    doubleEndNearestNeighborTSP,\r\n    minSpanTreeTSP\r\n} from './tsp';\r\nimport explanations from './explanations';\r\n\r\nconst INITIAL_COUNT = 20;\r\n\r\nfunction getRandomValue(max) {\r\n    return Math.random() * max;\r\n}\r\n\r\nfunction generateRandomData(count, max) {\r\n    return Array.from(Array(count)).map(() => ({x: getRandomValue(max), y: getRandomValue(max)}));\r\n}\r\n\r\nexport default class Graph extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            formula: eccentricEllipseTSP.altname,\r\n            data:  generateRandomData(INITIAL_COUNT, INITIAL_COUNT),\r\n            tsp: [],\r\n            lines: [],\r\n            bestCost: 0,\r\n            count: INITIAL_COUNT,\r\n            running: false,\r\n            highlightPt: []\r\n        }\r\n    }\r\n\r\n    internalUpdate = async (tsp, bestCost=0, lines=[], highlightPt=[]) => {\r\n        await this.setState({tsp, bestCost, lines, highlightPt});\r\n    }\r\n\r\n    startTSPCalculation = async () => {\r\n        const {formula} = this.state;\r\n        let tsp = [];\r\n\r\n        this.setState({running: true});\r\n        this.internalUpdate(tsp, 0, [], []);\r\n\r\n        switch (formula) {\r\n            case largestAngleTSP.altname:\r\n                tsp = await largestAngleTSP(this.state.data, this.internalUpdate);\r\n                break;\r\n            case eccentricEllipseTSP.altname:\r\n                tsp = await eccentricEllipseTSP(this.state.data, this.internalUpdate);\r\n                break;\r\n            case nearestNeighborTSP.altname:\r\n                tsp = await nearestNeighborTSP(this.state.data, this.internalUpdate);\r\n                break;\r\n            case nearestNeighborMultiTSP.altname:\r\n                tsp = await nearestNeighborMultiTSP(this.state.data, this.internalUpdate);\r\n                break;\r\n            case nearestAdditionTSP.altname:\r\n                tsp = await nearestAdditionTSP(this.state.data, this.internalUpdate);\r\n                break;\r\n            case farthestAdditionTSP.altname:\r\n                tsp = await farthestAdditionTSP(this.state.data, this.internalUpdate);\r\n                break;\r\n            case randomAdditionTSP.altname:\r\n                tsp = await randomAdditionTSP(this.state.data, this.internalUpdate);\r\n                break;\r\n            case doubleEndNearestNeighborTSP.altname:\r\n                tsp = await doubleEndNearestNeighborTSP(this.state.data, this.internalUpdate);\r\n                break;\r\n            case minSpanTreeTSP.altname:\r\n                tsp = await minSpanTreeTSP(this.state.data, this.internalUpdate);\r\n                break;\r\n            default:\r\n                tsp = []\r\n        }\r\n\r\n        this.setState({tsp, lines: [], running: false, highlightPt: []});\r\n    }\r\n\r\n    getNewData = () => {\r\n        this.setState({data: generateRandomData(this.state.count, this.state.count), tsp: 0})\r\n    }\r\n\r\n    addDataPoints = (count) => {\r\n        this.setState((state, _) => ({data: state.data.concat(generateRandomData(count - state.data.length, state.count))}))\r\n    }\r\n\r\n    removeDataPoints = (count) => {\r\n        this.setState((state, _) => ({data: state.data.slice(0, state.data.length - count)}))\r\n    }\r\n\r\n    updateCount = (count) => {\r\n        if (count < this.state.count) {\r\n            this.removeDataPoints(count);\r\n        } else {\r\n            this.addDataPoints(count);\r\n        }\r\n        this.setState({count, tsp: [], lines: []});\r\n    }\r\n    \r\n    render() {\r\n        const {tsp, data, formula, count, bestCost, lines, running, highlightPt} = this.state;\r\n\r\n        let explanation = explanations ? explanations[formula].join(\" \") : \"\";\r\n\r\n        return <div>\r\n            <div id='graph'>\r\n                <FlexibleWidthXYPlot \r\n                    height={350}\r\n                    xDomain={[0-count/10, count+count/10]}\r\n                    yDomain={[0-count/10, count+count/10]}\r\n                >\r\n                    <VerticalGridLines />\r\n                    <HorizontalGridLines />\r\n                    <XAxis />\r\n                    <YAxis />\r\n                    <MarkSeries\r\n                        data={data}\r\n                        animation\r\n                    />\r\n                    <LineSeries\r\n                        data={tsp.length ? tsp.concat(tsp[0]) : []}\r\n                    />\r\n                    {lines.map(line => (\r\n                        <LineSeries\r\n                            key={JSON.stringify(line)}\r\n                            data={line}\r\n                            style={{\r\n                                stroke: 'pink',\r\n                                strokeWidth: 5\r\n                            }}\r\n                        />\r\n                        )\r\n                    )}\r\n                    {highlightPt.length ? <MarkSeries\r\n                        data={highlightPt}\r\n                    /> : undefined }\r\n                </FlexibleWidthXYPlot>\r\n            </div>\r\n            <Row>\r\n                <Col>\r\n                    {\"Best Cost: \"} \r\n                    {bestCost.toFixed(2)}\r\n                </Col>\r\n                <Col>\r\n                    {\"Current Cost: \"} \r\n                    {calculateCost(tsp).toFixed(2)}\r\n                </Col>\r\n            </Row>\r\n\r\n            <RangeSlider \r\n                value={count}\r\n                onChange={(e) => this.updateCount(Number(e.target.value))}\r\n                tooltip='on'\r\n                disabled={running}\r\n                min={5}\r\n            />\r\n            <br/>\r\n            <Button className=\"my-3\" onClick={this.getNewData} disabled={running}>Randomize Points</Button>\r\n            <Form.Row>\r\n                <Col>\r\n                    <Form.Control\r\n                        value={formula}\r\n                        onChange={(event) => this.setState({formula: event.target.value})}\r\n                        as='select' \r\n                        custom\r\n                    >\r\n                        <option value={eccentricEllipseTSP.altname}>Most Eccentric Ellipse</option>\r\n                        <option value={largestAngleTSP.altname}>Largest Angle</option>\r\n                        <option value={nearestNeighborTSP.altname}>Nearest Neighbor</option>\r\n                        <option value={doubleEndNearestNeighborTSP.altname}>Double-ended Nearest Neighbor</option>\r\n                        <option value={nearestNeighborMultiTSP.altname}>Multi-ended Nearest Neighbor</option>\r\n                        <option value={nearestAdditionTSP.altname}>Nearest Addition</option>\r\n                        <option value={farthestAdditionTSP.altname}>Farthest Addition</option>\r\n                        <option value={randomAdditionTSP.altname}>Random Addition</option>\r\n                        <option value={minSpanTreeTSP.altname}>Min Span Tree</option>\r\n                    </Form.Control>\r\n                </Col>\r\n                <Col>\r\n                    <Button onClick={this.startTSPCalculation} disabled={running}>Run TSP</Button>\r\n                </Col>\r\n            </Form.Row>\r\n            <p className=\"pt-4 text-left\">\r\n                {explanation}\r\n            </p>\r\n        </div>\r\n    }\r\n}","import './App.css';\r\nimport React from 'react';\r\nimport Graph from './Graph';\r\nimport { Col, Container, Row, Tabs, Tab } from 'react-bootstrap';\r\n\r\nclass App extends React.Component {\r\n  render() {\r\n    return (\r\n      <div className=\"App\">\r\n        <Container fluid>\r\n          <Row>\r\n            <Col md={7}>\r\n              <h1>Geometric Solutiosn to TSP</h1>\r\n              <h2>A report and exploration</h2>\r\n              <h3>by Quintin Reed</h3>\r\n              <Tabs defaultActiveKey='default'>\r\n                <Tab eventKey='default' title=\"Introduction\">\r\n                  <div className='text-left mx-auto w-75 text-indent-md pt-2'>\r\n                    <p>\r\n                      TSP exists as one of the most studied NP-Complete problems to date, being that its approximations are important for many business areas. \r\n                      Describing breifly to the unknowing of TSP, TSP or Traveling Salesman Problem is a non-deterministic polynomially-verifiable algorithm \r\n                      where the goal is to minimize the cost of travel between nodes in a graph. Geometric solutions exist for where there are Euclidean distances involved, \r\n                      and such that, this website will solely focus on Euclidean distances and cartesian coordinate systems.\r\n                    </p>\r\n                    <p>\r\n                      This website acts as a agglomeration of various geometric techniques I have researched to help approximate the TSP, \r\n                      with its major purpose being to act as a showcase and aid to anyone researching the topic or field of study. \r\n                      Additionally, this website will not be looking at the other methods for solving TSPs, specifically List-based methods, e.g. Simulated Annealing. \r\n                      This website only focuses on Geometric solutions that are more based in the world of a coordinate system.\r\n                    </p>\r\n                    <p>\r\n                      As with all these methods, there is a heavy reliance on two things, the cost function, and a heuristic. \r\n                      The cost function for this website specifically is just a sum of the distances of all the edges. However, other forms of TSP exist, \r\n                      like AngleTSP where the edge distances are minimized, but so too are the turning angles [3]. The heuristic helps for functions to identify what's good and bad. \r\n                      In the provided functions, the variants of TSP under each category have different heuristics to determine what next point to add and where to add it, \r\n                      but share the same structure for solution. An example is the use of Largest Angle vs Eccentric Ellipse for the Convex Hull techniques for solving TSP.\r\n                    </p>\r\n                    <p>\r\n                      Below are two images comparing the efficiency in terms of time and accuracy across all the methods you can see on this page. More info on why they perform\r\n                      the way they do is on the Detailed Overview tab.\r\n                    </p>\r\n                    <Row className='text-indent-0'>\r\n                      <Col xl={6}>\r\n                        <img src={process.env.PUBLIC_URL + \"/time_chart.svg\"} width='400'/>\r\n                      </Col>\r\n                      <Col xl={6}>\r\n                        <img src={process.env.PUBLIC_URL + \"/cost_chart.svg\"} width='400'/>\r\n                      </Col>\r\n                    </Row>\r\n                    <p>\r\n                      For more information on these techniques, or for information on the process for creation of this project, \r\n                      please visit the other tabs and play with the demo.\r\n                    </p>\r\n                  </div>\r\n                </Tab>\r\n                <Tab eventKey='timeline' title=\"Project Timeline\">\r\n                  <div className='mx-auto w-75 text-left pt-2'>\r\n                    <p>\r\n                      Below is a list of how the project progressed for the different weeks. \r\n                      The project is bundled into what is relatively two halves, one focused on implementation of the algorithms described, \r\n                      and one focused on the creation of the demo and website.\r\n                    </p>\r\n                    <dl>\r\n                      <dt>Week 6-9</dt>\r\n                        <dd>\r\n                          <ul>\r\n                            <li>Gather equations from various papers</li>\r\n                            <li>Recreated algorithms in Python3</li>\r\n                            <li>Compared the algorithms that were made by time complexity and accuracy</li>\r\n                            <li>Designed a midpoint presentation to explain progress</li>\r\n                          </ul>\r\n                        </dd>\r\n                      <dt>Week 10 - 14</dt>\r\n                        <dd>\r\n                          <ul>\r\n                            <li>Update algorithms and features based on feedback from presentation</li>\r\n                            <li>Finish implentation of algorithms from the papers</li>\r\n                            <li>Recreate functions made in Python to JavaScript</li>\r\n                            <li>Create the website and demo application</li>\r\n                          </ul>\r\n                        </dd>\r\n                      <dt>Week 15</dt>\r\n                        <dd>\r\n                          <ul>\r\n                            <li>Final Presentation</li>\r\n                            <li>Finalize and Publish the demo website</li>\r\n                          </ul>\r\n                        </dd>\r\n                    </dl>\r\n                    <p>\r\n                      For project presentations related to this, you can find the historical presentations below\r\n                    </p>\r\n                    <h4 className='pt-2'>Final</h4>\r\n                    <iframe title=\"Final Presentation\" src=\"https://docs.google.com/presentation/d/e/2PACX-1vRQkLT5PAtpGipAiIocHkjNS2eKxZ48qYegg6Aykg-YWAHl98j3ICdkhcMq-n9nQrSdjCjuOzvV1zP4/embed?start=false&loop=false&delayms=3000\" frameborder=\"0\" width=\"480\" height=\"299\" allowfullscreen=\"true\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\"></iframe>                  \r\n                    <h4 className='pt-2'>Midpoint</h4>\r\n                    <iframe title=\"Midpoint Presentation\" src=\"https://docs.google.com/presentation/d/e/2PACX-1vSWTWOiKqb9CErfazN9mjc8c4r3kmA4O3O2AF__GEbHiH2MBOCl8n5LzgkuiVv4ZQhUuUiDvzMjSDJk/embed?start=false&loop=false&delayms=3000\" frameborder=\"0\" width=\"480\" height=\"299\" allowfullscreen=\"true\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\"></iframe>\r\n                    <h4 className='pt-2'>Initial</h4>\r\n                    <iframe title=\"Initial Presentation\" src=\"https://docs.google.com/presentation/d/e/2PACX-1vQyIgX_Lbp-2j0USrGHN-TX2E6smut4OyijfzYq6bPdT4oge7i16i6SQ7wT2cKqyn89WcFXRaeZF-uP/embed?start=false&loop=false&delayms=3000\" frameborder=\"0\" width=\"480\" height=\"299\" allowfullscreen=\"true\" mozallowfullscreen=\"true\" webkitallowfullscreen=\"true\"></iframe>\r\n                  </div>\r\n                </Tab>\r\n                <Tab eventKey=\"detail\" title=\"Detailed Overview\">\r\n                  <div className=\"pt-2 w-75 mx-auto text-left\">\r\n                    <p>These methods for solving TSP include various techniques and heuristics, listed below:</p>\r\n                    <dl>\r\n                      <dt>Convex Hull Techniques</dt>\r\n                        <dd>\r\n                          <ul>\r\n                            <li>Largest Angle [1]</li>\r\n                            <li>Most Eccentric Ellipse [1]</li>\r\n                          </ul>\r\n                          <p>\r\n                            Convex Hull Techniques rely on finding the convex hull for the set of points. \r\n                            From the convex hull, we iterate through the remaining points, using either the largest angle or eccentric ellipse heuristic to determine insertion order.\r\n                            Convex Hull based methods perform with great accuracy on \"randomly\" chosen points, always tending to be close to the best value.\r\n                          </p>\r\n                          <p>Largest Angle refers to the angle that the point makes when inserted into a given location, the angle it makes as the vertex point to the point before and after.</p>\r\n                          <p>\r\n                            Most Eccentric Ellipse refers to the Eccentricity of an ellipse, \r\n                            calculated by the distance between the focii (the before and after point) divided by the sum of the distances to the focii\r\n                          </p>\r\n                        </dd>\r\n                      <dt>Nearest Neighbor Techniques</dt>\r\n                        <dd>\r\n                          <ul>\r\n                            <li>(Single-Ended) Nearest Neighbor [2]</li>\r\n                            <li>Double-Ended Nearest Neighbor [2]</li>\r\n                            <li>Mulit-Ended Nearest Neighbor [2]</li>\r\n                          </ul>\r\n                          <p>\r\n                            Nearest Neighbor Techniques utilize Nearest Neighbor to find the best points to add to the tour. \r\n                            Given a tour, it adds the point that is closest to the tour. \r\n                            Calculating the neighbors can be sped up using a kd-tree instead of calculating it every time. \r\n                            There are three different heuristics for Nearest Neighbor given above:\r\n                          </p>\r\n                          <p>\r\n                            Single-Ended Nearest Neighbor is the normal heuristic for Nearest Neighbor, we find the next best point to add to the tour.\r\n                            This method iterates through every starting point, since its very dependent on which point is the start.\r\n                            Because of the iteration it has one of the higher time complexities of those methods listed here, \r\n                            however it is able to achieve a good accuracy on average.\r\n                          </p>\r\n                          <p>\r\n                            Double-Ended Nearest Neighbor uses as its distance the best distance to either endpoint of the existing tour and adds it at the appropriate end.\r\n                            This method has the highest time complexity associated with the algorithms shown here, since it iterates through all known points as potential starting points.\r\n                            This method also achieves a very good accuracy because of it using every potential starting point.\r\n                          </p>\r\n                          <p>\r\n                            Multi-Ended Nearest Neighbor extends the nearest neighbor algorithm with a focus of building up the tour. The ME-NN creates a kd-tree for each\r\n                            potential point. These trees then get pruned by searching the lowest distance and adding it as an edge to the tour. \r\n                            After finding all the shortest edges until there is no points left, the tour is constructed based on those found edges.\r\n                          </p>\r\n                        </dd>\r\n                      <dt>Addition Techniques</dt>\r\n                        <dd>\r\n                          <ul>\r\n                            <li>Nearest Addition [2]</li>\r\n                            <li>Farthest Addition [2]</li>\r\n                            <li>Random Addition [2]</li>\r\n                          </ul>\r\n                          <p>\r\n                            Addition Techniques refer to smarter methods of nearest neighbor utilizing a smart insertion technique rather than simply appending the point\r\n                            to either end of the tour. These methods utilize a heuristic for finding the best point \r\n                            and then add the point into the tour based on where it would achieve the lowest cost.\r\n                            These methods perform on par with Convex Hull techniques for time complexity, however they tend to perform more poorly on overall cost metrics,\r\n                            with Farthest addition usually performing the worst.\r\n                          </p>\r\n                          <p>\r\n                            Nearest Addition is the closest to nearest neighbor. The notion here is to start by randomly shuffling points, \r\n                            choosing the first point in the list, and constructing a kd-tree of the current tour points to be able \r\n                            to calculate the point with the shortest distance to the existing tour. \r\n                            Each point that is found then finds the best insertion point into the tour.\r\n                          </p>\r\n                          <p>\r\n                            Farthest Addition is the opposite of the previous method, \r\n                            instead of finding the points with the shortest distance to the existing tour, \r\n                            we find the points with the farthest distance from the tour points and add those first.\r\n                            This heuristic has proven to be the worst performing for the cost of the tour.\r\n                          </p>\r\n                          <p>\r\n                            Random Addition is what it sounds like, we choose a point randomly and then find the best location for insertion in the existing tour.\r\n                            This heuristic is the second worst performing, performing just a bit better than Farthest Addition.\r\n                          </p>\r\n                        </dd>\r\n                        <dt>Minimum Spanning Tree [2]</dt>\r\n                        <dd>\r\n                          This method has a few different heuristics it can optimize, however for the purpose of this paper we are only caring\r\n                          about the standard method for creation from an MST. For this method, we find the MST, \r\n                          and from it we traverse through the points adjacent to the current point in a Pre-order traversal to form the TSP. \r\n                          For the purposes of this project, the order of the adjacent points, left, right, etc. are considered arbitrary.\r\n                        </dd>\r\n                    </dl>\r\n                  </div>\r\n                </Tab>\r\n                <Tab eventKey=\"bibliography\" title=\"Bibliography\">\r\n                  <div className='pt-2 mx-auto w-95'>\r\n                    <ol className='text-left'>\r\n                      <li>Norback, J., & Love, R. (1977). \r\n                          <cite>Geometric Approaches to Solving the Traveling Salesman Problem. Management Science, 23(11), 1208-1223.</cite> \r\n                          <a href=\"http://www.jstor.org/stable/2630660\">http://www.jstor.org/stable/2630660</a>\r\n                      </li>\r\n                      <li>Bentley, J. J. (1992). \r\n                          <cite>Fast Algorithms for Geometric Traveling Salesman Problems. ORSA Journal on Computing, 4(4), 387.</cite>\r\n                          <a href=\"https://doi.org/10.1287/ijoc.4.4.387\">https://doi.org/10.1287/ijoc.4.4.387</a>\r\n                      </li>\r\n                      <li>Stanek Rostislav, et. al. (2019). \r\n                          <cite>Geometric and LP-based heuristics for angular travelling salesman problems in the plane. Computers & Operations Research, 108, 97-111.</cite> \r\n                          <a href=\"https://www.sciencedirect.com/science/article/pii/S0305054819300188\">https://www.sciencedirect.com/science/article/pii/S0305054819300188</a>\r\n                      </li>\r\n                    </ol>\r\n                  </div>\r\n                </Tab>\r\n              </Tabs>              \r\n            </Col>\r\n            <Col md={5} className=\"py-3\">\r\n              <Graph/>\r\n            </Col>\r\n          </Row>\r\n        </Container>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport 'react-vis/dist/style.css';\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\nimport 'react-bootstrap-range-slider/dist/react-bootstrap-range-slider.css';\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n  // <React.StrictMode>\r\n  <App />\r\n  // </React.StrictMode>\\\r\n  ,\r\n  document.getElementById('root')\r\n);"],"sourceRoot":""}