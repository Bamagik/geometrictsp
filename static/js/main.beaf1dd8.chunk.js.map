{"version":3,"sources":["funcs.js","tsp.js","Graph.js","App.js","reportWebVitals.js","index.js"],"names":["sleep","ms","Promise","resolve","setTimeout","TIMEOUTMS","calculateDistance","p","q","v","x","y","math","calculateAngle","r","v1","v2","findBestInsertionPoint","Y","R","tsp","points","kdTree","slice","nearest","length","bestCost","Infinity","bestIdx","console","log","sort","a","b","indexOf","pt","idx","P","Q","cost","calculateCost","calculateEccentricity","convexHull","updateFunc","hull","largestAngle","bestNextPoint","includes","angle","push","largestAngleTSP","difference","filter","lastLine","splice","concat","Number","eccentricEllipseTSP","largestEcc","ecc","nearestNeighborTSP","bestTSP","startIdx","remainingPoints","bestDist","dist","nearestNeighborMultiTSP","degree","Array","fill","tail","nnlink","pq","nn","edges","X","Ypt","remove","i","e","nearestAdditionTSP","sp","tree","insertIdx","thisDist","getRandomValue","max","Math","random","generateRandomData","count","from","map","Graph","props","internalUpdate","lines","setState","startTSPCalculation","formula","state","running","name","data","getNewData","addDataPoints","_","removeDataPoints","updateCount","this","height","xDomain","yDomain","animation","line","style","stroke","strokeWidth","JSON","stringify","Row","Col","toFixed","value","onChange","target","tooltip","Button","className","onClick","Form","Control","event","as","custom","disabled","explanations","join","React","Component","App","Container","fluid","md","Tabs","Tab","eventKey","title","href","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.beaf1dd8.chunk.js","sourcesContent":["\r\n/**\r\n * \r\n * @param {*} ms \r\n */\r\nexport function sleep(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n","import { kdTree } from 'kd-tree-javascript';\r\nimport * as math from 'mathjs';\r\nimport { sleep } from './funcs';\r\n\r\nconst TIMEOUTMS = 300;\r\nconst ADDRAD = 2\r\n\r\nfunction calculateDistance(p, q) {\r\n    const v = [p.x - q.x, p.y - q.y];\r\n    return math.norm(v);\r\n}\r\n\r\nfunction calculateAngle(p, q, r) {\r\n    const v1 = [q.x - p.x, q.y - p.y]\r\n    const v2 = [r.x - p.x, r.y - p.y]\r\n\r\n    return math.acos( math.divide(math.dot(v1, v2), (math.norm(v1) * math.norm(v2) ) ) )\r\n}\r\n\r\nfunction findBestInsertionPoint(Y, R, tsp) {\r\n    const tree = new kdTree(tsp.slice(), calculateDistance, ['x', 'y']);\r\n\r\n    let points = tree.nearest(Y, tsp.length, R * ADDRAD)\r\n\r\n    let bestCost = Infinity;\r\n    let bestIdx = null;\r\n\r\n    console.log(Y, tsp.slice())\r\n\r\n    points = points.sort((a, b) => tsp.indexOf(a[0]) - tsp.indexOf(b[0]))\r\n\r\n    for (let pt of points) {\r\n        const idx = tsp.indexOf(pt[0])\r\n        const P = tsp[idx]\r\n        const Q = tsp[(idx === 0 ? tsp.length : idx) - 1]\r\n\r\n        // console.log(P, Q)\r\n\r\n        let cost = calculateDistance(P, Y) + calculateDistance(Y, Q);\r\n\r\n        // console.log(cost)\r\n\r\n        if (cost < bestCost) {\r\n            bestIdx = idx;\r\n            bestCost = cost;\r\n        }\r\n    }\r\n\r\n    console.log(bestIdx, bestCost)\r\n\r\n    return bestIdx;\r\n}\r\n\r\nexport function calculateCost(tsp) {\r\n    let cost = 0;\r\n    for (const idx in tsp) {\r\n        const p = tsp[idx];\r\n        const q = tsp[(idx === '0' ? tsp.length : idx) - 1]\r\n\r\n        cost += calculateDistance(p, q);\r\n    }\r\n    return cost\r\n}\r\n\r\nfunction calculateEccentricity(p, q, r) {\r\n    return calculateDistance(q, r) / \r\n        ( calculateDistance(p, q) + calculateDistance(p, r) );\r\n}\r\n\r\nfunction nearestNeighbor(pt, points) {\r\n    let bestDist = Infinity;\r\n    let bestIdx = null;\r\n    \r\n    for (const idx in points) {\r\n        const q = points[idx];\r\n        const dist = calculateDistance(q, pt);\r\n        if (dist < bestDist) {\r\n            bestDist = dist;\r\n            bestIdx = idx;\r\n        }\r\n    }\r\n\r\n    return bestIdx;\r\n}\r\n\r\n\r\n/**\r\n * @param {Array} points \r\n */\r\nexport async function convexHull(points, updateFunc) {\r\n    points = points.sort((a, b) => a.x - b.x);\r\n\r\n    let hull = [points[0]];\r\n\r\n    if (updateFunc) {\r\n        await updateFunc(hull);\r\n        await sleep(TIMEOUTMS);\r\n    }\r\n    \r\n    let largestAngle = -Infinity;\r\n    let bestNextPoint = null;\r\n\r\n    for (const p of points) {\r\n        if (hull.includes(p)) {\r\n            continue;\r\n        }\r\n        for (const q of points) {\r\n            if (hull.includes(q) || p === q) {\r\n                continue;\r\n            }\r\n            const angle = calculateAngle(hull[hull.length-1], p, q)\r\n            if (angle > largestAngle) {\r\n                largestAngle = angle;\r\n                bestNextPoint = q;\r\n            }\r\n        }\r\n    }\r\n    hull.push(bestNextPoint);\r\n    if (updateFunc) {\r\n        await updateFunc(hull, 0, [hull.slice(hull.length - 2)]);\r\n        await sleep(TIMEOUTMS);\r\n    }\r\n\r\n    while(hull.length < points.length) {\r\n        largestAngle = -Infinity;\r\n        bestNextPoint = null;\r\n        for (const p of points) {\r\n            if (hull.slice(-2).includes(p)) {\r\n                continue;\r\n            }\r\n            const angle = calculateAngle(hull[hull.length - 1], p, hull[hull.length - 2])\r\n            if (angle > largestAngle) {\r\n                largestAngle = angle;\r\n                bestNextPoint = p;\r\n            }\r\n        }\r\n        if (bestNextPoint === hull[0]) {\r\n            break\r\n        }\r\n        hull.push(bestNextPoint);\r\n        if (updateFunc) {\r\n            await updateFunc(hull, 0, [hull.slice(hull.length - 2)]);\r\n            await sleep(TIMEOUTMS);\r\n        }\r\n    }\r\n\r\n    return hull;\r\n}\r\n\r\n/**\r\n * @param {Array} points \r\n */\r\nexport async function largestAngleTSP(points, updateFunc) {\r\n    let hull = await convexHull(points, updateFunc);\r\n\r\n    let difference = points.filter((p) => !hull.includes(p));\r\n    difference = difference.sort((a, b) => a.x - b.x);\r\n    // console.log(difference);\r\n\r\n    let lastLine = [];\r\n\r\n    for (const p of difference) {\r\n        if (updateFunc) {\r\n            await updateFunc(hull, 0, [lastLine]);\r\n            await sleep(TIMEOUTMS);\r\n        }\r\n\r\n        let largestAngle = -Infinity;\r\n        let bestIdx = null\r\n        \r\n        for (const idx in hull) {\r\n            const q = hull[idx];\r\n            const r = hull[(idx === '0' ? hull.length : idx) - 1];\r\n            const angle = calculateAngle(p, q, r);\r\n            if (angle > largestAngle) {\r\n                largestAngle = angle;\r\n                bestIdx = idx;\r\n            }\r\n        }\r\n        hull.splice(bestIdx, 0, p);\r\n\r\n        const r = hull[(bestIdx === '0' ? hull.length : bestIdx) - 1];\r\n        lastLine = [r].concat(hull.slice(Number(bestIdx), Number(bestIdx) + 2));\r\n    }\r\n\r\n    if (updateFunc) {\r\n        await updateFunc(hull, 0, [lastLine]);\r\n        await sleep(TIMEOUTMS);\r\n    }\r\n\r\n    return hull;\r\n}\r\n\r\n/**\r\n * \r\n * @param {*} points \r\n * @param {*} updateFunc \r\n */\r\nexport async function eccentricEllipseTSP(points, updateFunc) {\r\n    let hull = await convexHull(points, updateFunc);\r\n\r\n    let difference = points.filter((p) => !hull.includes(p));\r\n    difference = difference.sort((a, b) => a.x - b.x);\r\n    // console.log(difference);\r\n\r\n    let lastLine = [];\r\n\r\n    for (const p of difference) {\r\n        if (updateFunc) {\r\n            await updateFunc(hull, 0, [lastLine]);\r\n            await sleep(TIMEOUTMS);\r\n        }\r\n\r\n        let largestEcc = -Infinity;\r\n        let bestIdx = null;\r\n        \r\n        for (const idx in hull) {\r\n            const q = hull[idx];\r\n            const r = hull[(idx === '0' ? hull.length : idx) - 1];\r\n            const ecc = calculateEccentricity(p, q, r);\r\n            if (ecc > largestEcc) {\r\n                largestEcc = ecc;\r\n                bestIdx = idx;\r\n            }\r\n        }\r\n        hull.splice(bestIdx, 0, p);\r\n\r\n        const r = hull[(bestIdx === '0' ? hull.length : bestIdx) - 1];\r\n        lastLine = [r].concat(hull.slice(Number(bestIdx), Number(bestIdx) + 2));\r\n    }\r\n\r\n    if (updateFunc) {\r\n        await updateFunc(hull, 0, [lastLine]);\r\n        await sleep(TIMEOUTMS);\r\n    }\r\n\r\n    return hull;\r\n}\r\n\r\nexport async function nearestNeighborTSP(points, updateFunc) {\r\n    let bestCost = Infinity;\r\n    let bestTSP = null;\r\n\r\n    for (const startIdx in points) {\r\n        let tsp = [points[startIdx]];\r\n        let remainingPoints = [...points];\r\n        remainingPoints.splice(startIdx, 1);\r\n\r\n        while (tsp.length !== points.length) {\r\n            let bestDist = Infinity;\r\n            let bestIdx = null;\r\n\r\n            for (const idx in remainingPoints) {\r\n                const dist = calculateDistance(remainingPoints[idx], tsp[tsp.length - 1])\r\n                if (dist < bestDist) {\r\n                    bestDist = dist;\r\n                    bestIdx = idx;\r\n                }\r\n            }\r\n            tsp.push(remainingPoints[bestIdx]);\r\n            remainingPoints.splice(bestIdx, 1);\r\n\r\n            if (updateFunc) {\r\n                await updateFunc(tsp, bestCost, [tsp.slice(tsp.length-2)]);\r\n                await sleep(TIMEOUTMS/3);\r\n            }\r\n        }\r\n        const cost = calculateCost(tsp)\r\n        if (cost < bestCost) {\r\n            bestCost = cost;\r\n            bestTSP = tsp;\r\n        }\r\n\r\n        if (updateFunc) {\r\n            await updateFunc(tsp, bestCost, [tsp.slice(tsp.length-2)]);\r\n            await sleep(TIMEOUTMS/3);\r\n        }\r\n    }\r\n    return bestTSP;\r\n}\r\n\r\n/**\r\n * \r\n * @param {Array} points \r\n * @param {Function} updateFunc \r\n */\r\nexport async function nearestNeighborMultiTSP(points, updateFunc) {\r\n    let degree = Array(points.length).fill(0);\r\n    let tail = Array(points.length).fill(-1);\r\n    let nnlink = [];\r\n    let pq = [];\r\n\r\n    for (const idx in points) {\r\n        let remainingPoints = points.slice();\r\n        remainingPoints.splice(idx, 1);\r\n        nnlink.push(new kdTree(remainingPoints, calculateDistance, [\"x\", \"y\"]));\r\n        pq.push({nn: nnlink[idx].nearest(points[idx], 1)[0], idx: Number(idx)})\r\n    }\r\n\r\n    let edges = []\r\n\r\n    let X, Y, nn = null;\r\n\r\n    while (edges.length < points.length - 1) {\r\n        if (updateFunc) {\r\n            await updateFunc([], 0, edges);\r\n            await sleep(TIMEOUTMS);\r\n        }\r\n\r\n        while (true) {\r\n            pq = pq.sort((a, b) => a.nn[1] - b.nn[1]);\r\n            nn = pq[0].nn;\r\n            X = pq[0].idx;\r\n            if (degree[X] === 2) {\r\n                pq.splice(0, 1);\r\n                continue;\r\n            }\r\n            const [Ypt, thisDist] = nn;\r\n            Y = points.indexOf(Ypt);\r\n            \r\n            if (degree[Y] < 2 && Y !== tail[X]) {\r\n                break;\r\n            }\r\n            if (tail[X] !== -1) {\r\n                nnlink[X].remove(points[tail[X]]);\r\n            }\r\n            pq.splice(0, 1);\r\n            pq.push({nn: nnlink[X].nearest(points[X], 1)[0], idx: X});\r\n        }\r\n\r\n        edges.push([points[X], points[Y]]);\r\n        degree[X] += 1;\r\n        degree[Y] += 1;\r\n        if (degree[X] === 2) {\r\n            for (const tree of nnlink) {\r\n                tree.remove(points[X]);\r\n            }\r\n        }\r\n        if (degree[Y] === 2) {\r\n            for (const tree of nnlink) {\r\n                tree.remove(points[Y]);\r\n            }\r\n        }\r\n        pq.splice(0, 1);\r\n        pq.push({nn: nnlink[X].nearest(points[X], 1)[0], idx: X})\r\n\r\n        if (tail[X] !== -1) {\r\n            if (tail[Y] !== -1) {\r\n                tail[tail[X]] = tail[Y];\r\n                tail[tail[Y]] = tail[X];\r\n            } else {\r\n                tail[tail[X]] = Y;\r\n                tail[Y] = tail[X];\r\n            }\r\n        } else {\r\n            if (tail[Y] !== -1) {\r\n                tail[X] = tail[Y];\r\n                tail[tail[Y]] = X;\r\n            } else {\r\n                tail[X] = Y;\r\n                tail[Y] = X;\r\n            }\r\n        }\r\n    }\r\n\r\n    let tsp = [edges[0][0], edges[0][1]]\r\n\r\n    console.log(edges);\r\n    edges.splice(0, 1);\r\n\r\n    while (tsp.length < points.length) {\r\n        let i;\r\n        for (i in edges) {\r\n            const e = edges[i];\r\n            if (e[0] === tsp[0] && tsp[1] !== e[1]) {\r\n                tsp.splice(0, 0, e[1]);\r\n            } else if (e[1] === tsp[0] && tsp[1] !== e[0]) {\r\n                tsp.splice(0, 0, e[0]);\r\n            } else if (e[0] === tsp[tsp.length - 1] && tsp[tsp.length - 2] !== e[1]) {\r\n                tsp.push(e[1]);\r\n            } else if (e[1] === tsp[tsp.length - 1] && tsp[tsp.length - 2] !== e[0]) {\r\n                tsp.push(e[0]);\r\n            } else {\r\n                continue;\r\n            }\r\n            break;\r\n        }\r\n        edges.splice(i, 1);\r\n    }\r\n\r\n    return tsp;\r\n}\r\n\r\n/**\r\n * \r\n * @param {Array} points \r\n * @param {Function} updateFunc \r\n */\r\nexport async function nearestAdditionTSP(points, updateFunc) {\r\n    let idx = 0;\r\n    const sp = points[idx];\r\n\r\n    console.log(points)\r\n\r\n    let remainingPoints = points.slice();\r\n    remainingPoints.splice(idx, 1);\r\n\r\n    let tree = new kdTree(remainingPoints, calculateDistance, ['x', 'y']);\r\n    let pq = [{nn: tree.nearest(sp, 1)[0], idx: Number(idx)}]\r\n\r\n    let tsp = [sp];\r\n    let insertIdx = 0;\r\n\r\n    while (tsp.length < points.length) {\r\n        let Y, thisDist, Ypt;\r\n\r\n        if (updateFunc) {\r\n            const cost = calculateCost(tsp);\r\n            \r\n            let edges = []\r\n            if (tsp.length > 1) {\r\n                edges.push(tsp[(insertIdx - 1 === -1) ? tsp.length - 1: insertIdx - 1]);\r\n                edges.push(tsp[insertIdx]);\r\n                edges.push(tsp[(insertIdx + 1 === tsp.length) ? 1 : insertIdx + 1])\r\n            }\r\n            await updateFunc(tsp, cost, [edges]);\r\n            await sleep(TIMEOUTMS);\r\n        }\r\n\r\n        while (true) {\r\n            pq = pq.sort((a, b) => a.nn[1] - b.nn[1]);\r\n            // console.log(pq)\r\n            const nn = pq[0].nn;\r\n            const X = pq[0].idx;    \r\n            [Ypt, thisDist] = nn;\r\n            Y = points.indexOf(Ypt);\r\n\r\n            if (!tsp.includes(Ypt)) {\r\n                break;\r\n            }\r\n            tree.remove(Ypt);\r\n            pq.splice(0, 1);\r\n            pq.push({nn: tree.nearest(points[X], 1)[0], idx: X});\r\n        }\r\n\r\n        insertIdx = findBestInsertionPoint(points[Y], thisDist, tsp);\r\n        tsp.splice(insertIdx, 0, points[Y]);\r\n        console.log(tsp.slice())\r\n        remainingPoints.splice(remainingPoints.indexOf(points[Y]), 1);\r\n        tree.remove(points[Y]);\r\n\r\n        pq = []\r\n        for (let pt of tsp) {\r\n            pq.push({nn: tree.nearest(pt, 1)[0], idx: points.indexOf(pt)})\r\n        }\r\n    }\r\n\r\n    if (updateFunc) {\r\n        const cost = calculateCost(tsp);\r\n        await updateFunc(tsp, cost);\r\n        await sleep(TIMEOUTMS);\r\n    }\r\n    \r\n    return tsp;\r\n}\r\n\r\n/**\r\n * \r\n * @param {*} points \r\n * @param {*} updateFunc \r\n */\r\nexport async function minSpanTreeTSP(points, updateFunc) {\r\n    return null;\r\n}","import React from 'react';\r\nimport { Button, Col, Form, Row } from 'react-bootstrap';\r\nimport RangeSlider from 'react-bootstrap-range-slider';\r\nimport {\r\n    XAxis,\r\n    YAxis,\r\n    HorizontalGridLines,\r\n    VerticalGridLines,\r\n    MarkSeries,\r\n    LineSeries,\r\n    FlexibleWidthXYPlot\r\n} from 'react-vis'\r\nimport { calculateCost, eccentricEllipseTSP, largestAngleTSP, nearestNeighborMultiTSP, nearestNeighborTSP, nearestAdditionTSP } from './tsp';\r\nimport explanations from './explanations.json'\r\n\r\nconst INITIAL_COUNT = 20;\r\n\r\nfunction getRandomValue(max) {\r\n    return Math.random() * max;\r\n}\r\n\r\nfunction generateRandomData(count, max) {\r\n    return Array.from(Array(count)).map(() => ({x: getRandomValue(max), y: getRandomValue(max)}));\r\n}\r\n\r\nexport default class Graph extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            formula: eccentricEllipseTSP.name,\r\n            data:  generateRandomData(INITIAL_COUNT, INITIAL_COUNT),\r\n            tsp: [],\r\n            lines: [],\r\n            bestCost: 0,\r\n            count: INITIAL_COUNT,\r\n            running: false\r\n        }\r\n    }\r\n\r\n    internalUpdate = async (tsp, bestCost=0, lines=[]) => {\r\n        await this.setState({tsp, bestCost, lines});\r\n    }\r\n\r\n    startTSPCalculation = async () => {\r\n        const {formula} = this.state;\r\n        let tsp = [];\r\n\r\n        this.setState({running: true})\r\n\r\n        switch (formula) {\r\n            case largestAngleTSP.name:\r\n                tsp = await largestAngleTSP(this.state.data, this.internalUpdate);\r\n                break;\r\n            case eccentricEllipseTSP.name:\r\n                tsp = await eccentricEllipseTSP(this.state.data, this.internalUpdate);\r\n                break;\r\n            case nearestNeighborTSP.name:\r\n                tsp = await nearestNeighborTSP(this.state.data, this.internalUpdate);\r\n                break;\r\n            case nearestNeighborMultiTSP.name:\r\n                tsp = await nearestNeighborMultiTSP(this.state.data, this.internalUpdate);\r\n                break;\r\n            case nearestAdditionTSP.name:\r\n                tsp = await nearestAdditionTSP(this.state.data, this.internalUpdate);\r\n                break;\r\n            default:\r\n                tsp = []\r\n        }\r\n\r\n        this.setState({tsp, lines: [], running: false});\r\n    }\r\n\r\n    getNewData = () => {\r\n        // this.setState({data: generateRandomData(this.state.count, this.state.count), tsp: 0})\r\n    }\r\n\r\n    addDataPoints = (count) => {\r\n        this.setState((state, _) => ({data: state.data.concat(generateRandomData(count - state.data.length, state.count))}))\r\n    }\r\n\r\n    removeDataPoints = (count) => {\r\n        this.setState((state, _) => ({data: state.data.slice(0, state.data.length - count)}))\r\n    }\r\n\r\n    updateCount = (count) => {\r\n        if (count < this.state.count) {\r\n            this.removeDataPoints(count);\r\n        } else {\r\n            this.addDataPoints(count);\r\n        }\r\n        this.setState({count, tsp: [], lines: []});\r\n    }\r\n    \r\n    render() {\r\n        const {tsp, data, formula, count, bestCost, lines, running} = this.state\r\n\r\n        return <div>\r\n            <FlexibleWidthXYPlot height={300}\r\n                xDomain={[0-count/10, count+count/10]}\r\n                yDomain={[0-count/10, count+count/10]}\r\n            >\r\n                <VerticalGridLines />\r\n                <HorizontalGridLines />\r\n                <XAxis />\r\n                <YAxis />\r\n                <MarkSeries\r\n                    data={data}\r\n                    animation\r\n                />\r\n                <LineSeries\r\n                    data={tsp.length ? tsp.concat(tsp[0]) : []}\r\n                />\r\n                {lines.map(line => (\r\n                    <LineSeries\r\n                        key={JSON.stringify(line)}\r\n                        data={line}\r\n                        style={{\r\n                            stroke: 'pink',\r\n                            strokeWidth: 5\r\n                        }}\r\n                    />\r\n                    )\r\n                )}\r\n            </FlexibleWidthXYPlot>\r\n            <Row>\r\n                <Col>\r\n                    {\"Best Cost: \"} \r\n                    {bestCost.toFixed(2)}\r\n                </Col>\r\n                <Col>\r\n                    {\"Current Cost: \"} \r\n                    {calculateCost(tsp).toFixed(2)}\r\n                </Col>\r\n            </Row>\r\n\r\n            <RangeSlider \r\n                value={count}\r\n                onChange={(e) => this.updateCount(Number(e.target.value))}\r\n                tooltip='on'\r\n            />\r\n            <br/>\r\n            <Button className=\"my-3\" onClick={this.getNewData}>Randomize Points</Button>\r\n            <Form.Row>\r\n                <Col>\r\n                    <Form.Control\r\n                        value={formula}\r\n                        onChange={(event) => this.setState({formula: event.target.value})}\r\n                        as='select' \r\n                        custom\r\n                    >\r\n                        <option value={eccentricEllipseTSP.name}>Most Eccentric Ellipse</option>\r\n                        <option value={largestAngleTSP.name}>Largest Angle</option>\r\n                        <option value={nearestNeighborTSP.name}>Nearest Neighbor</option>\r\n                        <option value={nearestNeighborMultiTSP.name}>Multi-ended Nearest Neighbor</option>\r\n                        <option value={nearestAdditionTSP.name}>Nearest Addition</option>\r\n                    </Form.Control>\r\n                </Col>\r\n                <Col>\r\n                    <Button onClick={this.startTSPCalculation} disabled={running}>Run TSP</Button>\r\n                </Col>\r\n                <p className=\"pt-4 text-left\">\r\n                    {explanations[formula].join(\" \")}\r\n                </p>\r\n            </Form.Row>\r\n        </div>\r\n    }\r\n}","import './App.css';\nimport React from 'react';\nimport Graph from './Graph';\nimport { Col, Container, Row, Tabs, Tab } from 'react-bootstrap';\n\nclass App extends React.Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <Container fluid>\n          <Row>\n            <Col md={6}>\n              <h1>Geometric Solutiosn to TSP</h1>\n              <h2>A report and exploration</h2>\n              <h3>by Quintin Reed</h3>\n              <Tabs>\n                <Tab eventKey='default' title=\"Introduction\">\n                  <p>\n                    This website is a research into TSP methods using various Computational Geometry methods. \n                    These methods utilize various structures and algorithms to achieve their end results, \n                    and each method will be explained fully.\n                  </p>\n                  <p>\n                    The demo to the right of the screen allows the user to randomly generate up to 100 points and test out various methods\n                    of TSP calculation. On display, an explanation of the algorithm will also appear to guide you on what is happening.\n                  </p>\n                  <p>\n                    Click on other tabs to see the research into time and space complexity, \n                    as well as sample times and costs from random generated points. \n                    Additionally, click on the different tabs to see various info in regards to the research on this project.\n                  </p>\n                </Tab>\n                <Tab eventKey='timeline' title=\"Project Timeline\">\n                  <dl>\n                    <dt>Week 6-8</dt>\n                        <dd>\n                          <p>Gather equations and start looking at recreating the functions in python.</p>\n                        </dd>\n                    <dt>Week 9</dt>\n                        <dd>Focus on updating the website with findings and midproject presentation</dd>\n                    <dt>Week 10</dt>\n                        <dd>Show findings and update progress according to response from presentation</dd>\n                    <dt>Week 11 - 14</dt>\n                        <dd>Recreate functions in JavaScript and create a website to showcase and visualize multiple TSP solutions</dd>\n                    <dt>Week 15</dt>\n                        <dd>Final Presentation and Finalize Website</dd>\n                  </dl>\n                </Tab>\n                <Tab eventKey=\"Description\" title=\"Detailed Overview\">\n                  <p>\n                    These methods for solving TSP include various techniques, listed below:\n                    <div className='mx-auto w-50'>\n                      <ul className='text-left'>\n                        <li>Largest Angle Convex Hull</li>\n                        <li>Most Eccentric Ellipse Convex Hull</li>\n                        <li>Single-Ended Nearest Neighbor</li>\n                        <li>Double-Ended Nearest Neighbor</li>\n                        <li>Multi-Ended Nearest Neighbor</li>\n                        <li>Nearest Addition</li>\n                        <li>Farthest Addition</li>\n                        <li>Random Addition</li>\n                        <li>Minimum Spanning Tree</li>\n                      </ul>\n                    </div>\n                  </p>\n                </Tab>\n                <Tab eventKey=\"bibliography\" title=\"Bibliography\">\n                  <ol className='text-left'>\n                    <li>Norback, J., & Love, R. (1977). \n                        <cite>Geometric Approaches to Solving the Traveling Salesman Problem. Management Science, 23(11), 1208-1223.</cite> \n                        <a href=\"http://www.jstor.org/stable/2630660\">http://www.jstor.org/stable/2630660</a>\n                    </li>\n                    <li>Bentley, J. J. (1992). \n                        <cite>Fast Algorithms for Geometric Traveling Salesman Problems. ORSA Journal on Computing, 4(4), 387.</cite>\n                        <a href=\"https://doi-org.ezproxy.rit.edu/10.1287/ijoc.4.4.387\">https://doi-org.ezproxy.rit.edu/10.1287/ijoc.4.4.387</a>\n                    </li>\n                    <li>Stanek Rostislav, et. al. (2019). \n                        <cite>Geometric and LP-based heuristics for angular travelling salesman problems in the plane. Compturs & Operations Research, 108, 97-111.</cite> \n                        <a href=\"https://www-sciencedirect-com.ezproxy.rit.edu/science/article/pii/S0305054819300188\">https://www-sciencedirect-com.ezproxy.rit.edu/science/article/pii/S0305054819300188</a>\n                    </li>\n                  </ol>\n                </Tab>\n              </Tabs>              \n            </Col>\n            <Col md={6} className=\"py-3\">\n              <Graph/>\n            </Col>\n          </Row>\n        </Container>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport 'react-vis/dist/style.css';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport 'react-bootstrap-range-slider/dist/react-bootstrap-range-slider.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}