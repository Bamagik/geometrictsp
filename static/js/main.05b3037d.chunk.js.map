{"version":3,"sources":["funcs.js","tsp.js","explanations.js","Graph.js","App.js","index.js"],"names":["sleep","ms","Promise","resolve","setTimeout","math","require","TIMEOUTMS","calculateDistance","p","q","v","x","y","norm","calculateAngle","r","v1","v2","acos","divide","dot","findBestInsertionPoint","Y","R","tsp","points","kdTree","slice","nearest","length","bestCost","Infinity","bestIdx","console","log","sort","a","b","indexOf","pt","idx","P","Q","cost","calculateCost","calculateEccentricity","convexHull","updateFunc","hull","largestAngle","bestNextPoint","includes","angle","push","largestAngleTSP","difference","filter","lastLine","splice","concat","Number","eccentricEllipseTSP","largestEcc","ecc","nearestNeighborTSP","bestTSP","startIdx","remainingPoints","bestDist","dist","nearestNeighborMultiTSP","degree","Array","fill","tail","nnlink","pq","nn","edges","X","Ypt","remove","i","e","nearestAdditionTSP","pointsCopy","Math","random","sp","tree","insertIdx","thisDist","farthestAdditionTSP","nnin","Xpt","oldX","insert","randomAdditionTSP","pop","altname","explanations","getRandomValue","max","generateRandomData","count","from","map","Graph","props","internalUpdate","lines","setState","startTSPCalculation","formula","state","running","data","getNewData","addDataPoints","_","removeDataPoints","updateCount","this","explanation","join","height","xDomain","yDomain","animation","line","style","stroke","strokeWidth","JSON","stringify","Row","Col","toFixed","value","onChange","target","tooltip","Button","className","onClick","Form","Control","event","as","custom","disabled","React","Component","App","Container","fluid","md","Tabs","defaultActiveKey","Tab","eventKey","title","href","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.05b3037d.chunk.js","sourcesContent":["\r\n/**\r\n * \r\n * @param {*} ms \r\n */\r\nexport function sleep(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n","import { kdTree } from 'kd-tree-javascript';\r\nimport { sleep } from './funcs';\r\n\r\nconst math = require('mathjs');\r\n\r\nconst TIMEOUTMS = 300;\r\nconst ADDRAD = 2\r\n\r\nfunction calculateDistance(p, q) {\r\n    const v = [p.x - q.x, p.y - q.y];\r\n    return math.norm(v);\r\n}\r\n\r\nfunction calculateAngle(p, q, r) {\r\n    const v1 = [q.x - p.x, q.y - p.y]\r\n    const v2 = [r.x - p.x, r.y - p.y]\r\n\r\n    return math.acos( math.divide(math.dot(v1, v2), (math.norm(v1) * math.norm(v2) ) ) )\r\n}\r\n\r\nfunction findBestInsertionPoint(Y, R, tsp) {\r\n    const tree = new kdTree(tsp.slice(), calculateDistance, ['x', 'y']);\r\n\r\n    let points = tree.nearest(Y, tsp.length, R * ADDRAD)\r\n\r\n    let bestCost = Infinity;\r\n    let bestIdx = null;\r\n\r\n    console.log(Y, tsp.slice())\r\n\r\n    points = points.sort((a, b) => tsp.indexOf(a[0]) - tsp.indexOf(b[0]))\r\n\r\n    for (let pt of points) {\r\n        const idx = tsp.indexOf(pt[0])\r\n        const P = tsp[idx]\r\n        const Q = tsp[(idx === 0 ? tsp.length : idx) - 1]\r\n\r\n        // console.log(P, Q)\r\n\r\n        let cost = calculateDistance(P, Y) + calculateDistance(Y, Q);\r\n\r\n        // console.log(cost)\r\n\r\n        if (cost < bestCost) {\r\n            bestIdx = idx;\r\n            bestCost = cost;\r\n        }\r\n    }\r\n\r\n    console.log(bestIdx, bestCost)\r\n\r\n    return bestIdx;\r\n}\r\n\r\nexport function calculateCost(tsp) {\r\n    let cost = 0;\r\n    for (const idx in tsp) {\r\n        const p = tsp[idx];\r\n        const q = tsp[(idx === '0' ? tsp.length : idx) - 1]\r\n\r\n        cost += calculateDistance(p, q);\r\n    }\r\n    return cost\r\n}\r\n\r\nfunction calculateEccentricity(p, q, r) {\r\n    return calculateDistance(q, r) / \r\n        ( calculateDistance(p, q) + calculateDistance(p, r) );\r\n}\r\n\r\nfunction nearestNeighbor(pt, points) {\r\n    let bestDist = Infinity;\r\n    let bestIdx = null;\r\n    \r\n    for (const idx in points) {\r\n        const q = points[idx];\r\n        const dist = calculateDistance(q, pt);\r\n        if (dist < bestDist) {\r\n            bestDist = dist;\r\n            bestIdx = idx;\r\n        }\r\n    }\r\n\r\n    return bestIdx;\r\n}\r\n\r\n\r\n/**\r\n * @param {Array} points \r\n */\r\nexport async function convexHull(points, updateFunc) {\r\n    points = points.sort((a, b) => a.x - b.x);\r\n\r\n    let hull = [points[0]];\r\n\r\n    if (updateFunc) {\r\n        await updateFunc(hull);\r\n        await sleep(TIMEOUTMS);\r\n    }\r\n    \r\n    let largestAngle = -Infinity;\r\n    let bestNextPoint = null;\r\n\r\n    for (const p of points) {\r\n        if (hull.includes(p)) {\r\n            continue;\r\n        }\r\n        for (const q of points) {\r\n            if (hull.includes(q) || p === q) {\r\n                continue;\r\n            }\r\n            const angle = calculateAngle(hull[hull.length-1], p, q)\r\n            if (angle > largestAngle) {\r\n                largestAngle = angle;\r\n                bestNextPoint = q;\r\n            }\r\n        }\r\n    }\r\n    hull.push(bestNextPoint);\r\n    if (updateFunc) {\r\n        await updateFunc(hull, 0, [hull.slice(hull.length - 2)]);\r\n        await sleep(TIMEOUTMS);\r\n    }\r\n\r\n    while(hull.length < points.length) {\r\n        largestAngle = -Infinity;\r\n        bestNextPoint = null;\r\n        for (const p of points) {\r\n            if (hull.slice(-2).includes(p)) {\r\n                continue;\r\n            }\r\n            const angle = calculateAngle(hull[hull.length - 1], p, hull[hull.length - 2])\r\n            if (angle > largestAngle) {\r\n                largestAngle = angle;\r\n                bestNextPoint = p;\r\n            }\r\n        }\r\n        if (bestNextPoint === hull[0]) {\r\n            break\r\n        }\r\n        hull.push(bestNextPoint);\r\n        if (updateFunc) {\r\n            await updateFunc(hull, 0, [hull.slice(hull.length - 2)]);\r\n            await sleep(TIMEOUTMS);\r\n        }\r\n    }\r\n\r\n    return hull;\r\n}\r\n\r\n/**\r\n * @param {Array} points \r\n */\r\nexport async function largestAngleTSP(points, updateFunc) {\r\n    let hull = await convexHull(points, updateFunc);\r\n\r\n    let difference = points.filter((p) => !hull.includes(p));\r\n    difference = difference.sort((a, b) => a.x - b.x);\r\n    // console.log(difference);\r\n\r\n    let lastLine = [];\r\n\r\n    for (const p of difference) {\r\n        if (updateFunc) {\r\n            await updateFunc(hull, 0, [lastLine]);\r\n            await sleep(TIMEOUTMS);\r\n        }\r\n\r\n        let largestAngle = -Infinity;\r\n        let bestIdx = null\r\n        \r\n        for (const idx in hull) {\r\n            const q = hull[idx];\r\n            const r = hull[(idx === '0' ? hull.length : idx) - 1];\r\n            const angle = calculateAngle(p, q, r);\r\n            if (angle > largestAngle) {\r\n                largestAngle = angle;\r\n                bestIdx = idx;\r\n            }\r\n        }\r\n        hull.splice(bestIdx, 0, p);\r\n\r\n        const r = hull[(bestIdx === '0' ? hull.length : bestIdx) - 1];\r\n        lastLine = [r].concat(hull.slice(Number(bestIdx), Number(bestIdx) + 2));\r\n    }\r\n\r\n    if (updateFunc) {\r\n        await updateFunc(hull, 0, [lastLine]);\r\n        await sleep(TIMEOUTMS);\r\n    }\r\n\r\n    return hull;\r\n}\r\nlargestAngleTSP.altname = \"largestAngleTSP\";\r\n\r\n/**\r\n * \r\n * @param {*} points \r\n * @param {*} updateFunc \r\n */\r\nexport async function eccentricEllipseTSP(points, updateFunc) {\r\n    let hull = await convexHull(points, updateFunc);\r\n\r\n    let difference = points.filter((p) => !hull.includes(p));\r\n    difference = difference.sort((a, b) => a.x - b.x);\r\n    // console.log(difference);\r\n\r\n    let lastLine = [];\r\n\r\n    for (const p of difference) {\r\n        if (updateFunc) {\r\n            await updateFunc(hull, 0, [lastLine]);\r\n            await sleep(TIMEOUTMS);\r\n        }\r\n\r\n        let largestEcc = -Infinity;\r\n        let bestIdx = null;\r\n        \r\n        for (const idx in hull) {\r\n            const q = hull[idx];\r\n            const r = hull[(idx === '0' ? hull.length : idx) - 1];\r\n            const ecc = calculateEccentricity(p, q, r);\r\n            if (ecc > largestEcc) {\r\n                largestEcc = ecc;\r\n                bestIdx = idx;\r\n            }\r\n        }\r\n        hull.splice(bestIdx, 0, p);\r\n\r\n        const r = hull[(bestIdx === '0' ? hull.length : bestIdx) - 1];\r\n        lastLine = [r].concat(hull.slice(Number(bestIdx), Number(bestIdx) + 2));\r\n    }\r\n\r\n    if (updateFunc) {\r\n        await updateFunc(hull, 0, [lastLine]);\r\n        await sleep(TIMEOUTMS);\r\n    }\r\n\r\n    return hull;\r\n}\r\neccentricEllipseTSP.altname = \"eccentricEllipseTSP\";\r\n\r\n/**\r\n * \r\n * @param {*} points \r\n * @param {*} updateFunc \r\n */\r\nexport async function nearestNeighborTSP(points, updateFunc) {\r\n    let bestCost = Infinity;\r\n    let bestTSP = null;\r\n\r\n    for (const startIdx in points) {\r\n        let tsp = [points[startIdx]];\r\n        let remainingPoints = [...points];\r\n        remainingPoints.splice(startIdx, 1);\r\n\r\n        while (tsp.length !== points.length) {\r\n            let bestDist = Infinity;\r\n            let bestIdx = null;\r\n\r\n            for (const idx in remainingPoints) {\r\n                const dist = calculateDistance(remainingPoints[idx], tsp[tsp.length - 1])\r\n                if (dist < bestDist) {\r\n                    bestDist = dist;\r\n                    bestIdx = idx;\r\n                }\r\n            }\r\n            tsp.push(remainingPoints[bestIdx]);\r\n            remainingPoints.splice(bestIdx, 1);\r\n\r\n            if (updateFunc) {\r\n                await updateFunc(tsp, bestCost, [tsp.slice(tsp.length-2)]);\r\n                await sleep(TIMEOUTMS/3);\r\n            }\r\n        }\r\n        const cost = calculateCost(tsp)\r\n        if (cost < bestCost) {\r\n            bestCost = cost;\r\n            bestTSP = tsp;\r\n        }\r\n\r\n        if (updateFunc) {\r\n            await updateFunc(tsp, bestCost, [tsp.slice(tsp.length-2)]);\r\n            await sleep(TIMEOUTMS/3);\r\n        }\r\n    }\r\n    return bestTSP;\r\n}\r\nnearestNeighborTSP.altname = \"nearestNeighborTSP\";\r\n\r\n/**\r\n * \r\n * @param {Array} points \r\n * @param {Function} updateFunc \r\n */\r\nexport async function nearestNeighborMultiTSP(points, updateFunc) {\r\n    let degree = Array(points.length).fill(0);\r\n    let tail = Array(points.length).fill(-1);\r\n    let nnlink = [];\r\n    let pq = [];\r\n\r\n    for (const idx in points) {\r\n        let remainingPoints = points.slice();\r\n        remainingPoints.splice(idx, 1);\r\n        nnlink.push(new kdTree(remainingPoints, calculateDistance, [\"x\", \"y\"]));\r\n        pq.push({nn: nnlink[idx].nearest(points[idx], 1)[0], idx: Number(idx)})\r\n    }\r\n\r\n    let edges = []\r\n\r\n    let X, Y, nn = null;\r\n\r\n    while (edges.length < points.length - 1) {\r\n        if (updateFunc) {\r\n            await updateFunc([], 0, edges);\r\n            await sleep(TIMEOUTMS);\r\n        }\r\n\r\n        while (true) {\r\n            pq = pq.sort((a, b) => a.nn[1] - b.nn[1]);\r\n            nn = pq[0].nn;\r\n            X = pq[0].idx;\r\n            if (degree[X] === 2) {\r\n                pq.splice(0, 1);\r\n                continue;\r\n            }\r\n            const [Ypt, thisDist] = nn;\r\n            Y = points.indexOf(Ypt);\r\n            \r\n            if (degree[Y] < 2 && Y !== tail[X]) {\r\n                break;\r\n            }\r\n            if (tail[X] !== -1) {\r\n                nnlink[X].remove(points[tail[X]]);\r\n            }\r\n            pq.splice(0, 1);\r\n            pq.push({nn: nnlink[X].nearest(points[X], 1)[0], idx: X});\r\n        }\r\n\r\n        edges.push([points[X], points[Y]]);\r\n        degree[X] += 1;\r\n        degree[Y] += 1;\r\n        if (degree[X] === 2) {\r\n            for (const tree of nnlink) {\r\n                tree.remove(points[X]);\r\n            }\r\n        }\r\n        if (degree[Y] === 2) {\r\n            for (const tree of nnlink) {\r\n                tree.remove(points[Y]);\r\n            }\r\n        }\r\n        pq.splice(0, 1);\r\n        pq.push({nn: nnlink[X].nearest(points[X], 1)[0], idx: X})\r\n\r\n        if (tail[X] !== -1) {\r\n            if (tail[Y] !== -1) {\r\n                tail[tail[X]] = tail[Y];\r\n                tail[tail[Y]] = tail[X];\r\n            } else {\r\n                tail[tail[X]] = Y;\r\n                tail[Y] = tail[X];\r\n            }\r\n        } else {\r\n            if (tail[Y] !== -1) {\r\n                tail[X] = tail[Y];\r\n                tail[tail[Y]] = X;\r\n            } else {\r\n                tail[X] = Y;\r\n                tail[Y] = X;\r\n            }\r\n        }\r\n    }\r\n\r\n    let tsp = [edges[0][0], edges[0][1]]\r\n\r\n    console.log(edges);\r\n    edges.splice(0, 1);\r\n\r\n    while (tsp.length < points.length) {\r\n        let i;\r\n        for (i in edges) {\r\n            const e = edges[i];\r\n            if (e[0] === tsp[0] && tsp[1] !== e[1]) {\r\n                tsp.splice(0, 0, e[1]);\r\n            } else if (e[1] === tsp[0] && tsp[1] !== e[0]) {\r\n                tsp.splice(0, 0, e[0]);\r\n            } else if (e[0] === tsp[tsp.length - 1] && tsp[tsp.length - 2] !== e[1]) {\r\n                tsp.push(e[1]);\r\n            } else if (e[1] === tsp[tsp.length - 1] && tsp[tsp.length - 2] !== e[0]) {\r\n                tsp.push(e[0]);\r\n            } else {\r\n                continue;\r\n            }\r\n            break;\r\n        }\r\n        edges.splice(i, 1);\r\n    }\r\n\r\n    return tsp;\r\n}\r\nnearestNeighborMultiTSP.altname = \"nearestNeighborMultiTSP\";\r\n\r\n/**\r\n * \r\n * @param {Array} points \r\n * @param {Function} updateFunc \r\n */\r\nexport async function nearestAdditionTSP(points, updateFunc) {\r\n    let idx = 0;\r\n\r\n    const pointsCopy = points.slice().sort(() => Math.random() - 0.5);\r\n\r\n    const sp = pointsCopy[idx];\r\n\r\n    // console.log(points)\r\n\r\n    let remainingPoints = pointsCopy.slice();\r\n    remainingPoints.splice(idx, 1);\r\n\r\n    let tree = new kdTree(remainingPoints, calculateDistance, ['x', 'y']);\r\n    let pq = [{nn: tree.nearest(sp, 1)[0], idx: Number(idx)}]\r\n\r\n    let tsp = [sp];\r\n    let insertIdx = 0;\r\n\r\n    while (tsp.length < pointsCopy.length) {\r\n        let Y, thisDist, Ypt;\r\n\r\n        if (updateFunc && tsp.length > 1) {            \r\n            let edges = []\r\n            if (tsp.length > 1) {\r\n                edges.push(tsp[(insertIdx - 1 === -1) ? tsp.length - 1: insertIdx - 1]);\r\n                edges.push(tsp[insertIdx]);\r\n                edges.push(tsp[(insertIdx + 1 === tsp.length) ? 1 : insertIdx + 1])\r\n            }\r\n            await updateFunc(tsp, 0, [edges]);\r\n            await sleep(TIMEOUTMS);\r\n        }\r\n\r\n        while (true) {\r\n            pq = pq.sort((a, b) => a.nn[1] - b.nn[1]);\r\n            // console.log(pq)\r\n            const nn = pq[0].nn;\r\n            const X = pq[0].idx;    \r\n            [Ypt, thisDist] = nn;\r\n            Y = pointsCopy.indexOf(Ypt);\r\n\r\n            if (!tsp.includes(Ypt)) {\r\n                break;\r\n            }\r\n            tree.remove(Ypt);\r\n            pq.splice(0, 1);\r\n            pq.push({nn: tree.nearest(pointsCopy[X], 1)[0], idx: X});\r\n        }\r\n\r\n        insertIdx = findBestInsertionPoint(pointsCopy[Y], thisDist, tsp);\r\n        tsp.splice(insertIdx, 0, pointsCopy[Y]);\r\n        console.log(tsp.slice())\r\n        remainingPoints.splice(remainingPoints.indexOf(pointsCopy[Y]), 1);\r\n        tree.remove(pointsCopy[Y]);\r\n\r\n        pq = []\r\n        for (let pt of tsp) {\r\n            pq.push({nn: tree.nearest(pt, 1)[0], idx: pointsCopy.indexOf(pt)})\r\n        }\r\n    }\r\n\r\n    if (updateFunc) {\r\n        await updateFunc(tsp);\r\n        await sleep(TIMEOUTMS);\r\n    }\r\n    \r\n    return tsp;\r\n}\r\nnearestAdditionTSP.altname = \"nearestAdditionTSP\";\r\n\r\n\r\n/**\r\n * \r\n * @param {*} points \r\n * @param {*} updateFunc \r\n */\r\nexport async function farthestAdditionTSP(points, updateFunc) {\r\n    let idx = 0;\r\n    const pointsCopy = points.slice().sort(() => Math.random() - 0.5);\r\n    const sp = pointsCopy[idx];\r\n\r\n    let tsp = [sp];\r\n    let tree = new kdTree(tsp, calculateDistance, ['x', 'y']);\r\n\r\n    let nnin = new Array(points.length);\r\n    let pq = []\r\n\r\n    let insertIdx = 0;\r\n\r\n    for (let i in points) {\r\n        if (Number(i) !== idx) {\r\n            nnin[i] = 0\r\n            pq.push({nn: tree.nearest(points[i], 1)[0], idx: i});\r\n        }\r\n    }\r\n\r\n    while (tsp.length < points.length) {\r\n        let thisDist, Xpt, Y, nn;\r\n\r\n        if (updateFunc && tsp.length > 1) {            \r\n            let edges = []\r\n            if (tsp.length > 1) {\r\n                edges.push(tsp[(insertIdx - 1 === -1) ? tsp.length - 1: insertIdx - 1]);\r\n                edges.push(tsp[insertIdx]);\r\n                edges.push(tsp[(insertIdx + 1 === tsp.length) ? 1 : insertIdx + 1])\r\n            }\r\n            await updateFunc(tsp, 0, [edges]);\r\n            await sleep(TIMEOUTMS);\r\n        }\r\n\r\n        while (true) {\r\n            pq = pq.sort((a, b) => a.nn[1] - b.nn[1]);\r\n            \r\n            nn = pq[pq.length-1].nn;\r\n            Y = pq[pq.length-1].idx;\r\n            [Xpt, thisDist] = nn;\r\n            const oldX = pointsCopy.indexOf(Xpt);\r\n            nnin[Y] = pointsCopy.indexOf(tree.nearest(pointsCopy[Y], 1)[0][0]);\r\n            let X = nnin[Y];\r\n            if (X === oldX) {\r\n                break; \r\n            }\r\n            pq.splice(pq.length-1, 1);\r\n            pq.push({nn: tree.nearest(pointsCopy[Y], 1)[0], idx: Y});\r\n        }\r\n\r\n        insertIdx = findBestInsertionPoint(pointsCopy[Y], thisDist, tsp);\r\n        tsp.splice(insertIdx, 0, pointsCopy[Y]);\r\n        tree.insert(pointsCopy[Y]);\r\n        pq.splice(pq.length-1, 1);\r\n    }\r\n\r\n    if (updateFunc) {\r\n        await updateFunc(tsp);\r\n        await sleep(TIMEOUTMS);\r\n    }\r\n\r\n    return tsp\r\n}\r\nfarthestAdditionTSP.altname = \"farthestAdditionTSP\";\r\n\r\n\r\n/**\r\n * \r\n * @param {*} points \r\n * @param {*} updateFunc \r\n */\r\nexport async function randomAdditionTSP(points, updateFunc) {\r\n    const pointsCopy = points.slice().sort(() => Math.random() - 0.5);\r\n    const idx = 0;\r\n    const sp = pointsCopy[0];\r\n\r\n    let tsp = [sp];\r\n    let tree = new kdTree(tsp, calculateDistance, ['x', 'y']);\r\n    \r\n    let remainingPoints = pointsCopy.slice();\r\n    remainingPoints.splice(idx, 1);\r\n\r\n    let insertIdx = 0;\r\n\r\n    while (tsp.length < points.length) {\r\n        const Ypt = remainingPoints.pop();\r\n        let [Xpt, thisDist] = tree.nearest(Ypt, 1)[0];\r\n\r\n        insertIdx = findBestInsertionPoint(Ypt, thisDist, tsp);\r\n        tsp.splice(insertIdx, 0, Ypt);\r\n        tree.insert(Ypt);\r\n\r\n        if (updateFunc) {            \r\n            let edges = []\r\n            if (tsp.length > 1) {\r\n                edges.push(tsp[(insertIdx - 1 === -1) ? tsp.length - 1: insertIdx - 1]);\r\n                edges.push(tsp[insertIdx]);\r\n                edges.push(tsp[(insertIdx + 1 === tsp.length) ? 1 : insertIdx + 1])\r\n            }\r\n            await updateFunc(tsp, 0, [edges]);\r\n            await sleep(TIMEOUTMS);\r\n        }\r\n    }\r\n\r\n    return tsp;\r\n}\r\nrandomAdditionTSP.altname = \"randomAdditionTSP\";\r\n\r\n\r\n/**\r\n * \r\n * @param {*} points \r\n * @param {*} updateFunc \r\n */\r\nexport async function minSpanTreeTSP(points, updateFunc) {\r\n    return null;\r\n}","export var explanations = {\r\n    \"largestAngleTSP\": \r\n        [\r\n            \"This method starts with finding the convex hull of the set of points.\",\r\n            \"From there we look at all the interal points starting from left to right,\",\r\n            \"and calculate between which existing points in the convex hull has the largest angle to the given point. [1]\"\r\n        ],\r\n    \"eccentricEllipseTSP\":\r\n        [\r\n            \"This method starts with finding the convex hull of the set of points.\",\r\n            \"From there we look at all the internal points starting from left to right,\",\r\n            \"and calculate between which existing points in the convex hull has teh most eccentric ellipse\",\r\n            \"with respect to the given point. [1]\"\r\n        ],\r\n    \"nearestNeighborTSP\":\r\n        [\r\n            \"This method is about finding the nearest point to the end of the current cycle.\",\r\n            \"Using every point as a potential starting point, it looks for the lowest cost tour through all the points,\",\r\n            \"basing the finding of the next point by nearest neighbor approach. [2]\"\r\n        ],\r\n    \"nearestNeighborMultiTSP\":\r\n        [\r\n            \"This method is an extension of the standard nearest neighbor approach.\",\r\n            \"This method adds edges from smallest to largest until a tour is achieved. [2]\"\r\n        ],\r\n    \"nearestAdditionTSP\":\r\n        [\r\n            \"This method is an optimized form of nearest neighbor.\",\r\n            \"Utilizing a KDTree, nearest addition assumes randomness in the starting points,\",\r\n            \"and from those adds points based on proximity to a point in the tsp, and inserts it smartly\",\r\n            \"based on where the minimum cost is in the tsp. [2]\"\r\n        ],\r\n    \"farthestAdditionTSP\":\r\n        [\r\n            \"This method is an optimized form of nearest neighbor.\",\r\n            \"Utilizing a KDTree, farthest addition assumes randomness in the starting points,\",\r\n            \"and from those adds points that are farthest from the tsp first. [2]\"\r\n        ],\r\n    \"randomAdditionTSP\":\r\n        [\r\n            \"This method is an optimized form of nearest neighbor.\",\r\n            \"Utilizing a KDTree, random addition takes random points and\",\r\n            \"finds optimal locations for insertion in the existing TSP. [2]\"\r\n        ],\r\n    \"undefined\": [ \"placeholder\" ]\r\n};\r\n\r\nexport default explanations;","import React from 'react';\r\nimport { Button, Col, Form, Row } from 'react-bootstrap';\r\nimport RangeSlider from 'react-bootstrap-range-slider';\r\nimport {\r\n    XAxis,\r\n    YAxis,\r\n    HorizontalGridLines,\r\n    VerticalGridLines,\r\n    MarkSeries,\r\n    LineSeries,\r\n    FlexibleWidthXYPlot\r\n} from 'react-vis';\r\nimport { calculateCost, eccentricEllipseTSP, largestAngleTSP, nearestNeighborMultiTSP, nearestNeighborTSP, nearestAdditionTSP, farthestAdditionTSP, randomAdditionTSP } from './tsp';\r\nimport explanations from './explanations';\r\n\r\nconst INITIAL_COUNT = 20;\r\n\r\nfunction getRandomValue(max) {\r\n    return Math.random() * max;\r\n}\r\n\r\nfunction generateRandomData(count, max) {\r\n    return Array.from(Array(count)).map(() => ({x: getRandomValue(max), y: getRandomValue(max)}));\r\n}\r\n\r\nexport default class Graph extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            formula: eccentricEllipseTSP.altname,\r\n            data:  generateRandomData(INITIAL_COUNT, INITIAL_COUNT),\r\n            tsp: [],\r\n            lines: [],\r\n            bestCost: 0,\r\n            count: INITIAL_COUNT,\r\n            running: false\r\n        }\r\n    }\r\n\r\n    internalUpdate = async (tsp, bestCost=0, lines=[]) => {\r\n        await this.setState({tsp, bestCost, lines});\r\n    }\r\n\r\n    startTSPCalculation = async () => {\r\n        const {formula} = this.state;\r\n        let tsp = [];\r\n\r\n        this.setState({running: true, tsp, lines: []})\r\n\r\n        switch (formula) {\r\n            case largestAngleTSP.altname:\r\n                tsp = await largestAngleTSP(this.state.data, this.internalUpdate);\r\n                break;\r\n            case eccentricEllipseTSP.altname:\r\n                tsp = await eccentricEllipseTSP(this.state.data, this.internalUpdate);\r\n                break;\r\n            case nearestNeighborTSP.altname:\r\n                tsp = await nearestNeighborTSP(this.state.data, this.internalUpdate);\r\n                break;\r\n            case nearestNeighborMultiTSP.altname:\r\n                tsp = await nearestNeighborMultiTSP(this.state.data, this.internalUpdate);\r\n                break;\r\n            case nearestAdditionTSP.altname:\r\n                tsp = await nearestAdditionTSP(this.state.data, this.internalUpdate);\r\n                break;\r\n            case farthestAdditionTSP.altname:\r\n                tsp = await farthestAdditionTSP(this.state.data, this.internalUpdate);\r\n                break;\r\n            case randomAdditionTSP.altname:\r\n                tsp = await randomAdditionTSP(this.state.data, this.internalUpdate);\r\n                break;\r\n            default:\r\n                tsp = []\r\n        }\r\n\r\n        this.setState({tsp, lines: [], running: false});\r\n    }\r\n\r\n    getNewData = () => {\r\n        this.setState({data: generateRandomData(this.state.count, this.state.count), tsp: 0})\r\n    }\r\n\r\n    addDataPoints = (count) => {\r\n        this.setState((state, _) => ({data: state.data.concat(generateRandomData(count - state.data.length, state.count))}))\r\n    }\r\n\r\n    removeDataPoints = (count) => {\r\n        this.setState((state, _) => ({data: state.data.slice(0, state.data.length - count)}))\r\n    }\r\n\r\n    updateCount = (count) => {\r\n        if (count < this.state.count) {\r\n            this.removeDataPoints(count);\r\n        } else {\r\n            this.addDataPoints(count);\r\n        }\r\n        this.setState({count, tsp: [], lines: []});\r\n    }\r\n    \r\n    render() {\r\n        const {tsp, data, formula, count, bestCost, lines, running} = this.state;\r\n\r\n        console.log(formula)\r\n\r\n        let explanation = explanations ? explanations[formula].join(\" \") : \"\";\r\n\r\n        // let explanation = explanations[\"undefined\"];\r\n\r\n        return <div>\r\n            <FlexibleWidthXYPlot height={300}\r\n                xDomain={[0-count/10, count+count/10]}\r\n                yDomain={[0-count/10, count+count/10]}\r\n            >\r\n                <VerticalGridLines />\r\n                <HorizontalGridLines />\r\n                <XAxis />\r\n                <YAxis />\r\n                <MarkSeries\r\n                    data={data}\r\n                    animation\r\n                />\r\n                <LineSeries\r\n                    data={tsp.length ? tsp.concat(tsp[0]) : []}\r\n                />\r\n                {lines.map(line => (\r\n                    <LineSeries\r\n                        key={JSON.stringify(line)}\r\n                        data={line}\r\n                        style={{\r\n                            stroke: 'pink',\r\n                            strokeWidth: 5\r\n                        }}\r\n                    />\r\n                    )\r\n                )}\r\n            </FlexibleWidthXYPlot>\r\n            <Row>\r\n                <Col>\r\n                    {\"Best Cost: \"} \r\n                    {bestCost.toFixed(2)}\r\n                </Col>\r\n                <Col>\r\n                    {\"Current Cost: \"} \r\n                    {calculateCost(tsp).toFixed(2)}\r\n                </Col>\r\n            </Row>\r\n\r\n            <RangeSlider \r\n                value={count}\r\n                onChange={(e) => this.updateCount(Number(e.target.value))}\r\n                tooltip='on'\r\n            />\r\n            <br/>\r\n            <Button className=\"my-3\" onClick={this.getNewData}>Randomize Points</Button>\r\n            <Form.Row>\r\n                <Col>\r\n                    <Form.Control\r\n                        value={formula}\r\n                        onChange={(event) => this.setState({formula: event.target.value})}\r\n                        as='select' \r\n                        custom\r\n                    >\r\n                        <option value={eccentricEllipseTSP.altname}>Most Eccentric Ellipse</option>\r\n                        <option value={largestAngleTSP.altname}>Largest Angle</option>\r\n                        <option value={nearestNeighborTSP.altname}>Nearest Neighbor</option>\r\n                        <option value={nearestNeighborMultiTSP.altname}>Multi-ended Nearest Neighbor</option>\r\n                        <option value={nearestAdditionTSP.altname}>Nearest Addition</option>\r\n                        <option value={farthestAdditionTSP.altname}>Farthest Addition</option>\r\n                        <option value={randomAdditionTSP.altname}>Random Addition</option>\r\n                    </Form.Control>\r\n                </Col>\r\n                <Col>\r\n                    <Button onClick={this.startTSPCalculation} disabled={running}>Run TSP</Button>\r\n                </Col>\r\n            </Form.Row>\r\n            <p className=\"pt-4 text-left\">\r\n                {explanation}\r\n            </p>\r\n        </div>\r\n    }\r\n}","import './App.css';\nimport React from 'react';\nimport Graph from './Graph';\nimport { Col, Container, Row, Tabs, Tab } from 'react-bootstrap';\n\nclass App extends React.Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <Container fluid>\n          <Row>\n            <Col md={6}>\n              <h1>Geometric Solutiosn to TSP</h1>\n              <h2>A report and exploration</h2>\n              <h3>by Quintin Reed</h3>\n              <Tabs defaultActiveKey='default'>\n                <Tab eventKey='default' title=\"Introduction\">\n                  <div>\n                    <p>\n                      This website is a research into TSP methods using various Computational Geometry methods. \n                      These methods utilize various structures and algorithms to achieve their end results, \n                      and each method will be explained fully.\n                    </p>\n                    <p>\n                      The demo to the right of the screen allows the user to randomly generate up to 100 points and test out various methods\n                      of TSP calculation. On display, an explanation of the algorithm will also appear to guide you on what is happening.\n                    </p>\n                    <p>\n                      Click on other tabs to see the research into time and space complexity, \n                      as well as sample times and costs from random generated points. \n                      Additionally, click on the different tabs to see various info in regards to the research on this project.\n                    </p>\n                  </div>\n                </Tab>\n                <Tab eventKey='timeline' title=\"Project Timeline\">\n                  <div>\n                    <dl>\n                      <dt>Week 6-8</dt>\n                          <dd>\n                            <p>Gather equations and start looking at recreating the functions in python.</p>\n                          </dd>\n                      <dt>Week 9</dt>\n                          <dd>Focus on updating the website with findings and midproject presentation</dd>\n                      <dt>Week 10</dt>\n                          <dd>Show findings and update progress according to response from presentation</dd>\n                      <dt>Week 11 - 14</dt>\n                          <dd>Recreate functions in JavaScript and create a website to showcase and visualize multiple TSP solutions</dd>\n                      <dt>Week 15</dt>\n                          <dd>Final Presentation and Finalize Website</dd>\n                    </dl>\n                  </div>\n                </Tab>\n                <Tab eventKey=\"Description\" title=\"Detailed Overview\">\n                  <div>\n                    These methods for solving TSP include various techniques, listed below:\n                    <div className='mx-auto w-50'>\n                      <ul className='text-left'>\n                        <li>Largest Angle Convex Hull</li>\n                        <li>Most Eccentric Ellipse Convex Hull</li>\n                        <li>Single-Ended Nearest Neighbor</li>\n                        <li>Double-Ended Nearest Neighbor</li>\n                        <li>Multi-Ended Nearest Neighbor</li>\n                        <li>Nearest Addition</li>\n                        <li>Farthest Addition</li>\n                        <li>Random Addition</li>\n                        <li>Minimum Spanning Tree</li>\n                      </ul>\n                    </div>\n                  </div>\n                </Tab>\n                <Tab eventKey=\"bibliography\" title=\"Bibliography\">\n                  <div>\n                    <ol className='text-left'>\n                      <li>Norback, J., & Love, R. (1977). \n                          <cite>Geometric Approaches to Solving the Traveling Salesman Problem. Management Science, 23(11), 1208-1223.</cite> \n                          <a href=\"http://www.jstor.org/stable/2630660\">http://www.jstor.org/stable/2630660</a>\n                      </li>\n                      <li>Bentley, J. J. (1992). \n                          <cite>Fast Algorithms for Geometric Traveling Salesman Problems. ORSA Journal on Computing, 4(4), 387.</cite>\n                          <a href=\"https://doi-org.ezproxy.rit.edu/10.1287/ijoc.4.4.387\">https://doi-org.ezproxy.rit.edu/10.1287/ijoc.4.4.387</a>\n                      </li>\n                      <li>Stanek Rostislav, et. al. (2019). \n                          <cite>Geometric and LP-based heuristics for angular travelling salesman problems in the plane. Compturs & Operations Research, 108, 97-111.</cite> \n                          <a href=\"https://www-sciencedirect-com.ezproxy.rit.edu/science/article/pii/S0305054819300188\">https://www-sciencedirect-com.ezproxy.rit.edu/science/article/pii/S0305054819300188</a>\n                      </li>\n                    </ol>\n                  </div>\n                </Tab>\n              </Tabs>              \n            </Col>\n            <Col md={6} className=\"py-3\">\n              <Graph/>\n            </Col>\n          </Row>\n        </Container>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport 'react-vis/dist/style.css';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport 'react-bootstrap-range-slider/dist/react-bootstrap-range-slider.css';\nimport App from './App';\n\nReactDOM.render(\n  // <React.StrictMode>\n  <App />\n  // </React.StrictMode>\\\n  ,\n  document.getElementById('root')\n);"],"sourceRoot":""}